<?xml version="1.0" encoding="utf-8"?>






<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>sslouis</title>
        <link>https://sslouis.com/</link>
        <description>这是 reuixiy 的生活与技术博客！怎么记住 reuixiy 呢？其实就是「一休儿」的拼音，只不过顺序是从右往左……</description>
        <generator>Hugo 0.79.0 https://gohugo.io/</generator>
        
            <language>zh-CN</language>
        
        
            <managingEditor>sslouis22@gmail.com (sslouis)</managingEditor>
        
        
            <webMaster>sslouis22@gmail.com (sslouis)</webMaster>
        
        
            <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
        
        <lastBuildDate>Thu, 07 Apr 2022 16:16:34 &#43;0800</lastBuildDate>
        
            <atom:link rel="self" type="application/rss&#43;xml" href="https://sslouis.com/rss.xml" />
        
        
            <item>
                <title>Spring Boot是怎么启动的？</title>
                <link>https://sslouis.com/tech/spring-boot%E6%98%AF%E6%80%8E%E4%B9%88%E5%90%AF%E5%8A%A8%E7%9A%84/</link>
                <guid isPermaLink="true">https://sslouis.com/tech/spring-boot%E6%98%AF%E6%80%8E%E4%B9%88%E5%90%AF%E5%8A%A8%E7%9A%84/</guid>
                <pubDate>Wed, 24 Feb 2021 19:01:50 &#43;0800</pubDate>
                
                    <author>sslouis22@gmail.com (sslouis)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;p&gt;我们都知道Spring Boot启动只有一行代码，那就是
&lt;code&gt;SpringApplication.run(AdminApplication.class, args)&lt;/code&gt;
那它到底做了些什么呢？今天我们就来一探究竟。
先看这个&lt;code&gt;run&lt;/code&gt;方法的源码。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ConfigurableApplicationContext&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;run&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;//一个计时的工具，我们忽略
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;n&#34;&gt;StopWatch&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;stopWatch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;StopWatch&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;stopWatch&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;start&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;ConfigurableApplicationContext&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;context&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;Collection&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SpringBootExceptionReporter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;exceptionReporters&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ArrayList&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;configureHeadlessProperty&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;//获取监听器
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;n&#34;&gt;SpringApplicationRunListeners&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;listeners&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;getRunListeners&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;listeners&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;starting&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;try&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;n&#34;&gt;ApplicationArguments&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;applicationArguments&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DefaultApplicationArguments&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;//根据SpringApplicationRunListeners以及参数来准备环境
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;n&#34;&gt;ConfigurableEnvironment&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;environment&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;prepareEnvironment&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;listeners&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;applicationArguments&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
			&lt;span class=&#34;n&#34;&gt;configureIgnoreBeanInfo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;environment&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;//准备Banner打印器
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;n&#34;&gt;Banner&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;printedBanner&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;printBanner&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;environment&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;//创建Spring容器
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;n&#34;&gt;context&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;createApplicationContext&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
			&lt;span class=&#34;n&#34;&gt;exceptionReporters&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;getSpringFactoriesInstances&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SpringBootExceptionReporter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;class&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;
					&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Class&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ConfigurableApplicationContext&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;},&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;//Spring容器前置处理
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;n&#34;&gt;prepareContext&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;environment&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;listeners&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;applicationArguments&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;printedBanner&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;//刷新容器
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;n&#34;&gt;refreshContext&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;//Spring容器后置处理
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;n&#34;&gt;afterRefresh&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;applicationArguments&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
			&lt;span class=&#34;n&#34;&gt;stopWatch&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;stop&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;logStartupInfo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;StartupInfoLogger&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;mainApplicationClass&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;logStarted&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;getApplicationLog&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;stopWatch&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
			&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
			&lt;span class=&#34;n&#34;&gt;listeners&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;started&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;//执行Runners
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;n&#34;&gt;callRunners&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;applicationArguments&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
		&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;catch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Throwable&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ex&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;n&#34;&gt;handleRunFailure&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ex&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;exceptionReporters&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;listeners&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;IllegalStateException&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ex&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
		&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

		&lt;span class=&#34;k&#34;&gt;try&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;n&#34;&gt;listeners&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;running&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
		&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;catch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Throwable&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ex&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;n&#34;&gt;handleRunFailure&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ex&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;exceptionReporters&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;IllegalStateException&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ex&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
		&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
	&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;</description>
                
                
                
                    
                    
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/">tech</category>
                            
                        
                    
                
                
                
                    
                        
                    
                
            </item>
        
            <item>
                <title>SSL是什么</title>
                <link>https://sslouis.com/tech/ssl%E6%98%AF%E4%BB%80%E4%B9%88/</link>
                <guid isPermaLink="true">https://sslouis.com/tech/ssl%E6%98%AF%E4%BB%80%E4%B9%88/</guid>
                <pubDate>Wed, 13 Jan 2021 15:13:00 &#43;0800</pubDate>
                
                    <author>sslouis22@gmail.com (sslouis)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h2 id=&#34;heading&#34;&gt;&lt;/h2&gt;
&lt;p&gt;SSL:Secure Sockets Layer安全套接层
TLS：Transport Layer Sercurity传输层安全&lt;/p&gt;
&lt;h3 id=&#34;ssl&#34;&gt;SSL&lt;/h3&gt;
&lt;h3 id=&#34;基本运行过程&#34;&gt;基本运行过程&lt;/h3&gt;
&lt;p&gt;SSL/TLS协议的基本思路是采用公钥加密法。&lt;/p&gt;
</description>
                
                
                
                    
                    
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/">tech</category>
                            
                        
                    
                
                
                
                    
                        
                    
                
            </item>
        
            <item>
                <title>Redis</title>
                <link>https://sslouis.com/tech/redis/redis/</link>
                <guid isPermaLink="true">https://sslouis.com/tech/redis/redis/</guid>
                <pubDate>Fri, 01 Jan 2021 17:06:33 &#43;0800</pubDate>
                
                    <author>sslouis22@gmail.com (sslouis)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h2 id=&#34;redis数据结构&#34;&gt;Redis数据结构&lt;/h2&gt;
</description>
                
                
                
                    
                    
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/">tech</category>
                            
                        
                    
                        
                        
                        
                    
                
                
                
                    
                        
                    
                
            </item>
        
            <item>
                <title>类文件结构</title>
                <link>https://sslouis.com/tech/jvm/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</link>
                <guid isPermaLink="true">https://sslouis.com/tech/jvm/%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/</guid>
                <pubDate>Wed, 30 Dec 2020 20:13:57 &#43;0800</pubDate>
                
                    <author>sslouis22@gmail.com (sslouis)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h2 id=&#34;class类文件的结构&#34;&gt;Class类文件的结构&lt;/h2&gt;
&lt;p&gt;Class文件是一组以8个字节为基础单位的二进制流，&lt;/p&gt;
&lt;p&gt;CLass文件格式：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;类型&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;名称&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;数量&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;单元格&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;单元格&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;单元格&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;单元格&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;单元格&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;单元格&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
</description>
                
                
                
                    
                    
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/">tech</category>
                            
                        
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/jvm/">JVM</category>
                            
                        
                    
                
                
                
                    
                        
                    
                
            </item>
        
            <item>
                <title>Java高效并发</title>
                <link>https://sslouis.com/tech/jvm/java%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91/</link>
                <guid isPermaLink="true">https://sslouis.com/tech/jvm/java%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91/</guid>
                <pubDate>Sat, 26 Dec 2020 10:04:10 &#43;0800</pubDate>
                
                    <author>sslouis22@gmail.com (sslouis)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h2 id=&#34;锁优化&#34;&gt;锁优化&lt;/h2&gt;
&lt;h3 id=&#34;自旋锁与自适应自旋&#34;&gt;自旋锁与自适应自旋&lt;/h3&gt;
&lt;p&gt;让线程执行一个忙循环（自旋），等待上一个线程释放锁的过程。&lt;br&gt;
JDK6之后它是默认开启的，自旋次数的默认值是10次。&lt;br&gt;
自适应自旋会根据上一次同一个锁上的自旋时间及锁的拥有者的状态来决定。&lt;/p&gt;
&lt;h3 id=&#34;锁消除&#34;&gt;锁消除&lt;/h3&gt;
&lt;p&gt;锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。&lt;/p&gt;
&lt;h3 id=&#34;锁粗化&#34;&gt;锁粗化&lt;/h3&gt;
&lt;p&gt;如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体之中的，即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要的性能损耗。
如果虚拟机探测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。&lt;/p&gt;
&lt;h3 id=&#34;轻量级锁&#34;&gt;轻量级锁&lt;/h3&gt;
&lt;h3 id=&#34;偏向锁&#34;&gt;偏向锁&lt;/h3&gt;
</description>
                
                
                
                    
                    
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/">tech</category>
                            
                        
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/jvm/">JVM</category>
                            
                        
                    
                
                
                
                    
                        
                    
                
            </item>
        
            <item>
                <title>Java泛型的坑</title>
                <link>https://sslouis.com/tech/jvm/java%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%9D%91/</link>
                <guid isPermaLink="true">https://sslouis.com/tech/jvm/java%E6%B3%9B%E5%9E%8B%E7%9A%84%E5%9D%91/</guid>
                <pubDate>Fri, 25 Dec 2020 13:53:02 &#43;0800</pubDate>
                
                    <author>sslouis22@gmail.com (sslouis)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;p&gt;今天同事出现了类型检查的问题，其本质原因是Java在编译的时候将泛型直接擦除了，没有做类型验证。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;public static List&amp;lt;UnopDictData&amp;gt; getDictCache(String key) {
        Object cacheObj = SpringUtils.getBean(RedisCache.class).getCacheObject(getCacheKey(key));
        if (ObjectUtil.isNotNull(cacheObj)) {
            List&amp;lt;UnopDictData&amp;gt; dictDatas = StringUtil.cast(cacheObj);
            return dictDatas;
        }
        return null;
    }
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;同事写了这么一段代码，在后面对他调用的时候，发现list还是从&lt;code&gt;Redis&lt;/code&gt;取到的&lt;code&gt;LinkedHashMap&lt;/code&gt;,此时就报了类型检查的异常。&lt;/p&gt;
</description>
                
                
                
                    
                    
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/">tech</category>
                            
                        
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/jvm/">JVM</category>
                            
                        
                    
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://sslouis.com/tags/java/">Java</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Javac编译优化</title>
                <link>https://sslouis.com/tech/jvm/javac/</link>
                <guid isPermaLink="true">https://sslouis.com/tech/jvm/javac/</guid>
                <pubDate>Tue, 22 Dec 2020 07:06:22 &#43;0800</pubDate>
                
                    <author>sslouis22@gmail.com (sslouis)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h4 id=&#34;javac编译过程&#34;&gt;Javac编译过程&lt;/h4&gt;
&lt;p&gt;1.准备过程：初始化插入式注解处理器。&lt;br&gt;
2.解析与填充符号表过程：&lt;br&gt;
a.词法、语法分析。将源代码的字符流转变为标记集合，构造出抽象语法树。
b.填充符号表。产生符号地址和符号信息。
3.插入式注解处理器的注解处理过程：&lt;br&gt;
4.分析与字节码生成过程&lt;br&gt;
a.标注检查。对语法的静态信息进行检查。
b.数据流及控制流分析。对程序动态运行过程进行检查。
c.解语法糖。将简化代码编写的语法糖还原为原有的形式。
d.字节码生成。将前面各个步骤生成的信息转化成字节码。&lt;/p&gt;
</description>
                
                
                
                    
                    
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/">tech</category>
                            
                        
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/jvm/">JVM</category>
                            
                        
                    
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://sslouis.com/tags/java/">Java</category>
                                
                            
                                
                                
                                
                                    <category domain="https://sslouis.com/tags/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86/">编译原理</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>PriorityQueue笔记</title>
                <link>https://sslouis.com/tech/spring/priorityqueue/</link>
                <guid isPermaLink="true">https://sslouis.com/tech/spring/priorityqueue/</guid>
                <pubDate>Fri, 18 Dec 2020 20:33:32 &#43;0800</pubDate>
                
                    <author>sslouis22@gmail.com (sslouis)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h2 id=&#34;priorityqueue--优先级队列&#34;&gt;PriorityQueue  优先级队列&lt;/h2&gt;
&lt;h3 id=&#34;底层&#34;&gt;底层&lt;/h3&gt;
&lt;p&gt;使用了堆,可以自我调整的二叉树,对树执行添加(add)和删除(remove)操作,
可以让最小的元素移动到根,而不必花费时间对元素进行排序.&lt;/p&gt;
&lt;h3 id=&#34;典型事例&#34;&gt;典型事例&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;任务调度&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;代码待补充&#34;&gt;代码待补充&lt;/h3&gt;
</description>
                
                
                
                    
                    
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/">tech</category>
                            
                        
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/spring/">Spring</category>
                            
                        
                    
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://sslouis.com/tags/java-collections/">Java Collections</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>类加载器是什么？</title>
                <link>https://sslouis.com/tech/spring/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</link>
                <guid isPermaLink="true">https://sslouis.com/tech/spring/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8/</guid>
                <pubDate>Sun, 06 Dec 2020 18:28:36 &#43;0800</pubDate>
                
                    <author>sslouis22@gmail.com (sslouis)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h2 id=&#34;类加载器&#34;&gt;类加载器&lt;/h2&gt;
&lt;h3 id=&#34;三种类型&#34;&gt;三种类型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;根装载器
使用C++编写,负责装载JRE的核心类库&lt;/li&gt;
&lt;li&gt;ExtClassLoader(扩展类装载器) 装载JRE扩展目录ext中的JAR类包&lt;/li&gt;
&lt;li&gt;AppClassLoader(应用类装载器) 装载Classpath路径下的类包&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;全盘负责委托机制&#34;&gt;全盘负责委托机制&lt;/h3&gt;
&lt;p&gt;先委托父装载器寻找目标类,只有在找不到的情况下才从自己的类路径中查找并装载目标类.&lt;/p&gt;
&lt;h3 id=&#34;重要方法&#34;&gt;重要方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Class loadClass(String name)&lt;/code&gt;: name参数指定类装载器需要装载类的名字,必须使用全限定名.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Class defineClass(String name,byte[] b,int off,int len)&lt;/code&gt;:将类文件的字节数组转换成JVM内部的java.lang.Class对象.字节数组可以从本地文件系统,远程网络获取.
参数name为字节数组对应的全限定类名.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ClassLoader getParent()&lt;/code&gt;:获取类装载器的父装载器.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;class&#34;&gt;Class&lt;/h3&gt;
&lt;h4 id=&#34;方法&#34;&gt;方法&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Constructor&lt;/code&gt;
&lt;code&gt;Method&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;其他&#34;&gt;其他&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Class没有public的构造方法,Class对象是在装载类时由JVM通过调用类装载器中的defineClass()方法自动构造的.
可以看到加载了哪个类,srcAdd.jsp&lt;/li&gt;
&lt;li&gt;对于private或protected成员变量和方法
&lt;code&gt;field.setAccessible(true)&lt;/code&gt;
&lt;code&gt;method.setAccessible(true)&lt;/code&gt;
如果JVM的安全管理器设置了相应的安全机制,将抛出SecurityException&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;参考&amp;lt;精通Spring4.x--企业应用开发实战&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
                
                
                
                    
                    
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/">tech</category>
                            
                        
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/spring/">Spring</category>
                            
                        
                    
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://sslouis.com/tags/jvm/">JVM</category>
                                
                            
                                
                                
                                
                                    <category domain="https://sslouis.com/tags/spring/">Spring</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>WeakHashMap</title>
                <link>https://sslouis.com/tech/spring/weakhashmap/</link>
                <guid isPermaLink="true">https://sslouis.com/tech/spring/weakhashmap/</guid>
                <pubDate>Wed, 18 Nov 2020 00:00:00 &#43;0800</pubDate>
                
                    <author>sslouis22@gmail.com (sslouis)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h2 id=&#34;weakhashmap&#34;&gt;WeakHashMap&lt;/h2&gt;
</description>
                
                
                
                    
                    
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/">tech</category>
                            
                        
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/spring/">Spring</category>
                            
                        
                    
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://sslouis.com/tags/%E7%AE%97%E6%B3%95/">算法</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Vector</title>
                <link>https://sslouis.com/tech/spring/vector/</link>
                <guid isPermaLink="true">https://sslouis.com/tech/spring/vector/</guid>
                <pubDate>Mon, 09 Nov 2020 00:00:00 &#43;0800</pubDate>
                
                    <author>sslouis22@gmail.com (sslouis)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h2 id=&#34;vector&#34;&gt;Vector&lt;/h2&gt;
</description>
                
                
                
                    
                    
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/">tech</category>
                            
                        
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/spring/">Spring</category>
                            
                        
                    
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://sslouis.com/tags/%E7%AE%97%E6%B3%95/">算法</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>MySQL逻辑架构</title>
                <link>https://sslouis.com/tech/mysql/mysql1.0/</link>
                <guid isPermaLink="true">https://sslouis.com/tech/mysql/mysql1.0/</guid>
                <pubDate>Sun, 11 Oct 2020 14:20:00 &#43;0800</pubDate>
                
                    <author>sslouis22@gmail.com (sslouis)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;p&gt;####MySQL逻辑架构&lt;/p&gt;
</description>
                
                
                
                    
                    
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/">tech</category>
                            
                        
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/mysql/">MySQL</category>
                            
                        
                    
                
                
                
                    
                        
                    
                
            </item>
        
            <item>
                <title>cron的计算实现</title>
                <link>https://sslouis.com/tech/cron%E7%9A%84%E8%AE%A1%E7%AE%97%E5%AE%9E%E7%8E%B0/</link>
                <guid isPermaLink="true">https://sslouis.com/tech/cron%E7%9A%84%E8%AE%A1%E7%AE%97%E5%AE%9E%E7%8E%B0/</guid>
                <pubDate>Tue, 08 Sep 2020 13:12:27 &#43;0800</pubDate>
                
                    <author>sslouis22@gmail.com (sslouis)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;pre&gt;&lt;code&gt;public Date getTimeAfter(Date afterTime) {

        // Computation is based on Gregorian year only.
        // 获取当前时区的日历对象
        Calendar cl = new java.util.GregorianCalendar(getTimeZone()); 

        // move ahead one second, since we&#39;re computing the time *after* the
        // given time
        // 向前进1秒
        afterTime = new Date(afterTime.getTime() + 1000);
        // CronTrigger does not deal with milliseconds
        cl.setTime(afterTime);
        cl.set(Calendar.MILLISECOND, 0);

        boolean gotOne = false;
        // loop until we&#39;ve computed the next time, or we&#39;ve past the endTime
        while (!gotOne) {

            //if (endTime != null &amp;amp;&amp;amp; cl.getTime().after(endTime)) return null;
            if(cl.get(Calendar.YEAR) &amp;gt; 2999) { // prevent endless loop...
                return null;
            }

            SortedSet&amp;lt;Integer&amp;gt; st = null;
            int t = 0;

            int sec = cl.get(Calendar.SECOND);
            int min = cl.get(Calendar.MINUTE);

            // get second.................................................
            st = seconds.tailSet(sec);
            if (st != null &amp;amp;&amp;amp; st.size() != 0) {
                sec = st.first();
            } else {
                sec = seconds.first();
                min++;
                cl.set(Calendar.MINUTE, min);
            }
            cl.set(Calendar.SECOND, sec);

            min = cl.get(Calendar.MINUTE);
            int hr = cl.get(Calendar.HOUR_OF_DAY);
            t = -1;

            // get minute.................................................
            st = minutes.tailSet(min);
            if (st != null &amp;amp;&amp;amp; st.size() != 0) {
                t = min;
                min = st.first();
            } else {
                min = minutes.first();
                hr++;
            }
            if (min != t) {
                cl.set(Calendar.SECOND, 0);
                cl.set(Calendar.MINUTE, min);
                setCalendarHour(cl, hr);
                continue;
            }
            cl.set(Calendar.MINUTE, min);

            hr = cl.get(Calendar.HOUR_OF_DAY);
            int day = cl.get(Calendar.DAY_OF_MONTH);
            t = -1;

            // get hour...................................................
            st = hours.tailSet(hr);
            if (st != null &amp;amp;&amp;amp; st.size() != 0) {
                t = hr;
                hr = st.first();
            } else {
                hr = hours.first();
                day++;
            }
            if (hr != t) {
                cl.set(Calendar.SECOND, 0);
                cl.set(Calendar.MINUTE, 0);
                cl.set(Calendar.DAY_OF_MONTH, day);
                setCalendarHour(cl, hr);
                continue;
            }
            cl.set(Calendar.HOUR_OF_DAY, hr);

            day = cl.get(Calendar.DAY_OF_MONTH);
            int mon = cl.get(Calendar.MONTH) + 1;
            // &#39;+ 1&#39; because calendar is 0-based for this field, and we are
            // 1-based
            t = -1;
            int tmon = mon;
            
            // get day...................................................
            boolean dayOfMSpec = !daysOfMonth.contains(NO_SPEC);
            boolean dayOfWSpec = !daysOfWeek.contains(NO_SPEC);
            if (dayOfMSpec &amp;amp;&amp;amp; !dayOfWSpec) { // get day by day of month rule
                st = daysOfMonth.tailSet(day);
                if (lastdayOfMonth) {
                    if(!nearestWeekday) {
                        t = day;
                        day = getLastDayOfMonth(mon, cl.get(Calendar.YEAR));
                        day -= lastdayOffset;
                        if(t &amp;gt; day) {
                            mon++;
                            if(mon &amp;gt; 12) { 
                                mon = 1;
                                tmon = 3333; // ensure test of mon != tmon further below fails
                                cl.add(Calendar.YEAR, 1);
                            }
                            day = 1;
                        }
                    } else {
                        t = day;
                        day = getLastDayOfMonth(mon, cl.get(Calendar.YEAR));
                        day -= lastdayOffset;
                        
                        java.util.Calendar tcal = java.util.Calendar.getInstance(getTimeZone());
                        tcal.set(Calendar.SECOND, 0);
                        tcal.set(Calendar.MINUTE, 0);
                        tcal.set(Calendar.HOUR_OF_DAY, 0);
                        tcal.set(Calendar.DAY_OF_MONTH, day);
                        tcal.set(Calendar.MONTH, mon - 1);
                        tcal.set(Calendar.YEAR, cl.get(Calendar.YEAR));
                        
                        int ldom = getLastDayOfMonth(mon, cl.get(Calendar.YEAR));
                        int dow = tcal.get(Calendar.DAY_OF_WEEK);

                        if(dow == Calendar.SATURDAY &amp;amp;&amp;amp; day == 1) {
                            day += 2;
                        } else if(dow == Calendar.SATURDAY) {
                            day -= 1;
                        } else if(dow == Calendar.SUNDAY &amp;amp;&amp;amp; day == ldom) { 
                            day -= 2;
                        } else if(dow == Calendar.SUNDAY) { 
                            day += 1;
                        }
                    
                        tcal.set(Calendar.SECOND, sec);
                        tcal.set(Calendar.MINUTE, min);
                        tcal.set(Calendar.HOUR_OF_DAY, hr);
                        tcal.set(Calendar.DAY_OF_MONTH, day);
                        tcal.set(Calendar.MONTH, mon - 1);
                        Date nTime = tcal.getTime();
                        if(nTime.before(afterTime)) {
                            day = 1;
                            mon++;
                        }
                    }
                } else if(nearestWeekday) {
                    t = day;
                    day = daysOfMonth.first();

                    java.util.Calendar tcal = java.util.Calendar.getInstance(getTimeZone());
                    tcal.set(Calendar.SECOND, 0);
                    tcal.set(Calendar.MINUTE, 0);
                    tcal.set(Calendar.HOUR_OF_DAY, 0);
                    tcal.set(Calendar.DAY_OF_MONTH, day);
                    tcal.set(Calendar.MONTH, mon - 1);
                    tcal.set(Calendar.YEAR, cl.get(Calendar.YEAR));
                    
                    int ldom = getLastDayOfMonth(mon, cl.get(Calendar.YEAR));
                    int dow = tcal.get(Calendar.DAY_OF_WEEK);

                    if(dow == Calendar.SATURDAY &amp;amp;&amp;amp; day == 1) {
                        day += 2;
                    } else if(dow == Calendar.SATURDAY) {
                        day -= 1;
                    } else if(dow == Calendar.SUNDAY &amp;amp;&amp;amp; day == ldom) { 
                        day -= 2;
                    } else if(dow == Calendar.SUNDAY) { 
                        day += 1;
                    }
                        
                
                    tcal.set(Calendar.SECOND, sec);
                    tcal.set(Calendar.MINUTE, min);
                    tcal.set(Calendar.HOUR_OF_DAY, hr);
                    tcal.set(Calendar.DAY_OF_MONTH, day);
                    tcal.set(Calendar.MONTH, mon - 1);
                    Date nTime = tcal.getTime();
                    if(nTime.before(afterTime)) {
                        day = daysOfMonth.first();
                        mon++;
                    }
                } else if (st != null &amp;amp;&amp;amp; st.size() != 0) {
                    t = day;
                    day = st.first();
                    // make sure we don&#39;t over-run a short month, such as february
                    int lastDay = getLastDayOfMonth(mon, cl.get(Calendar.YEAR));
                    if (day &amp;gt; lastDay) {
                        day = daysOfMonth.first();
                        mon++;
                    }
                } else {
                    day = daysOfMonth.first();
                    mon++;
                }
                
                if (day != t || mon != tmon) {
                    cl.set(Calendar.SECOND, 0);
                    cl.set(Calendar.MINUTE, 0);
                    cl.set(Calendar.HOUR_OF_DAY, 0);
                    cl.set(Calendar.DAY_OF_MONTH, day);
                    cl.set(Calendar.MONTH, mon - 1);
                    // &#39;- 1&#39; because calendar is 0-based for this field, and we
                    // are 1-based
                    continue;
                }
            } else if (dayOfWSpec &amp;amp;&amp;amp; !dayOfMSpec) { // get day by day of week rule
                if (lastdayOfWeek) { // are we looking for the last XXX day of
                    // the month?
                    int dow = daysOfWeek.first(); // desired
                    // d-o-w
                    int cDow = cl.get(Calendar.DAY_OF_WEEK); // current d-o-w
                    int daysToAdd = 0;
                    if (cDow &amp;lt; dow) {
                        daysToAdd = dow - cDow;
                    }
                    if (cDow &amp;gt; dow) {
                        daysToAdd = dow + (7 - cDow);
                    }

                    int lDay = getLastDayOfMonth(mon, cl.get(Calendar.YEAR));

                    if (day + daysToAdd &amp;gt; lDay) { // did we already miss the
                        // last one?
                        cl.set(Calendar.SECOND, 0);
                        cl.set(Calendar.MINUTE, 0);
                        cl.set(Calendar.HOUR_OF_DAY, 0);
                        cl.set(Calendar.DAY_OF_MONTH, 1);
                        cl.set(Calendar.MONTH, mon);
                        // no &#39;- 1&#39; here because we are promoting the month
                        continue;
                    }

                    // find date of last occurrence of this day in this month...
                    while ((day + daysToAdd + 7) &amp;lt;= lDay) {
                        daysToAdd += 7;
                    }

                    day += daysToAdd;

                    if (daysToAdd &amp;gt; 0) {
                        cl.set(Calendar.SECOND, 0);
                        cl.set(Calendar.MINUTE, 0);
                        cl.set(Calendar.HOUR_OF_DAY, 0);
                        cl.set(Calendar.DAY_OF_MONTH, day);
                        cl.set(Calendar.MONTH, mon - 1);
                        // &#39;- 1&#39; here because we are not promoting the month
                        continue;
                    }

                } else if (nthdayOfWeek != 0) {
                    // are we looking for the Nth XXX day in the month?
                    int dow = daysOfWeek.first(); // desired
                    // d-o-w
                    int cDow = cl.get(Calendar.DAY_OF_WEEK); // current d-o-w
                    int daysToAdd = 0;
                    if (cDow &amp;lt; dow) {
                        daysToAdd = dow - cDow;
                    } else if (cDow &amp;gt; dow) {
                        daysToAdd = dow + (7 - cDow);
                    }

                    boolean dayShifted = false;
                    if (daysToAdd &amp;gt; 0) {
                        dayShifted = true;
                    }

                    day += daysToAdd;
                    int weekOfMonth = day / 7;
                    if (day % 7 &amp;gt; 0) {
                        weekOfMonth++;
                    }

                    daysToAdd = (nthdayOfWeek - weekOfMonth) * 7;
                    day += daysToAdd;
                    if (daysToAdd &amp;lt; 0
                            || day &amp;gt; getLastDayOfMonth(mon, cl
                                    .get(Calendar.YEAR))) {
                        cl.set(Calendar.SECOND, 0);
                        cl.set(Calendar.MINUTE, 0);
                        cl.set(Calendar.HOUR_OF_DAY, 0);
                        cl.set(Calendar.DAY_OF_MONTH, 1);
                        cl.set(Calendar.MONTH, mon);
                        // no &#39;- 1&#39; here because we are promoting the month
                        continue;
                    } else if (daysToAdd &amp;gt; 0 || dayShifted) {
                        cl.set(Calendar.SECOND, 0);
                        cl.set(Calendar.MINUTE, 0);
                        cl.set(Calendar.HOUR_OF_DAY, 0);
                        cl.set(Calendar.DAY_OF_MONTH, day);
                        cl.set(Calendar.MONTH, mon - 1);
                        // &#39;- 1&#39; here because we are NOT promoting the month
                        continue;
                    }
                } else {
                    int cDow = cl.get(Calendar.DAY_OF_WEEK); // current d-o-w
                    int dow = daysOfWeek.first(); // desired
                    // d-o-w
                    st = daysOfWeek.tailSet(cDow);
                    if (st != null &amp;amp;&amp;amp; st.size() &amp;gt; 0) {
                        dow = st.first();
                    }

                    int daysToAdd = 0;
                    if (cDow &amp;lt; dow) {
                        daysToAdd = dow - cDow;
                    }
                    if (cDow &amp;gt; dow) {
                        daysToAdd = dow + (7 - cDow);
                    }

                    int lDay = getLastDayOfMonth(mon, cl.get(Calendar.YEAR));

                    if (day + daysToAdd &amp;gt; lDay) { // will we pass the end of
                        // the month?
                        cl.set(Calendar.SECOND, 0);
                        cl.set(Calendar.MINUTE, 0);
                        cl.set(Calendar.HOUR_OF_DAY, 0);
                        cl.set(Calendar.DAY_OF_MONTH, 1);
                        cl.set(Calendar.MONTH, mon);
                        // no &#39;- 1&#39; here because we are promoting the month
                        continue;
                    } else if (daysToAdd &amp;gt; 0) { // are we swithing days?
                        cl.set(Calendar.SECOND, 0);
                        cl.set(Calendar.MINUTE, 0);
                        cl.set(Calendar.HOUR_OF_DAY, 0);
                        cl.set(Calendar.DAY_OF_MONTH, day + daysToAdd);
                        cl.set(Calendar.MONTH, mon - 1);
                        // &#39;- 1&#39; because calendar is 0-based for this field,
                        // and we are 1-based
                        continue;
                    }
                }
            } else { // dayOfWSpec &amp;amp;&amp;amp; !dayOfMSpec
                throw new UnsupportedOperationException(
                        &amp;quot;Support for specifying both a day-of-week AND a day-of-month parameter is not implemented.&amp;quot;);
            }
            cl.set(Calendar.DAY_OF_MONTH, day);

            mon = cl.get(Calendar.MONTH) + 1;
            // &#39;+ 1&#39; because calendar is 0-based for this field, and we are
            // 1-based
            int year = cl.get(Calendar.YEAR);
            t = -1;

            // test for expressions that never generate a valid fire date,
            // but keep looping...
            if (year &amp;gt; MAX_YEAR) {
                return null;
            }

            // get month...................................................
            st = months.tailSet(mon);
            if (st != null &amp;amp;&amp;amp; st.size() != 0) {
                t = mon;
                mon = st.first();
            } else {
                mon = months.first();
                year++;
            }
            if (mon != t) {
                cl.set(Calendar.SECOND, 0);
                cl.set(Calendar.MINUTE, 0);
                cl.set(Calendar.HOUR_OF_DAY, 0);
                cl.set(Calendar.DAY_OF_MONTH, 1);
                cl.set(Calendar.MONTH, mon - 1);
                // &#39;- 1&#39; because calendar is 0-based for this field, and we are
                // 1-based
                cl.set(Calendar.YEAR, year);
                continue;
            }
            cl.set(Calendar.MONTH, mon - 1);
            // &#39;- 1&#39; because calendar is 0-based for this field, and we are
            // 1-based

            year = cl.get(Calendar.YEAR);
            t = -1;

            // get year...................................................
            st = years.tailSet(year);
            if (st != null &amp;amp;&amp;amp; st.size() != 0) {
                t = year;
                year = st.first();
            } else {
                return null; // ran out of years...
            }

            if (year != t) {
                cl.set(Calendar.SECOND, 0);
                cl.set(Calendar.MINUTE, 0);
                cl.set(Calendar.HOUR_OF_DAY, 0);
                cl.set(Calendar.DAY_OF_MONTH, 1);
                cl.set(Calendar.MONTH, 0);
                // &#39;- 1&#39; because calendar is 0-based for this field, and we are
                // 1-based
                cl.set(Calendar.YEAR, year);
                continue;
            }
            cl.set(Calendar.YEAR, year);

            gotOne = true;
        } // while( !done )

        return cl.getTime();
    }

&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                    
                    
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/">tech</category>
                            
                        
                    
                
                
                
                    
                        
                    
                
            </item>
        
            <item>
                <title>Javac编译器是什么？</title>
                <link>https://sslouis.com/tech/javac/</link>
                <guid isPermaLink="true">https://sslouis.com/tech/javac/</guid>
                <pubDate>Thu, 03 Sep 2020 13:12:27 &#43;0800</pubDate>
                
                    <author>sslouis22@gmail.com (sslouis)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;p&gt;Javac编译器是由Java编写的程序。&lt;br&gt;
编译过程大致可以分为1个准备过程和3个处理过程：&lt;br&gt;
1）准备过程：初始化插入式注解处理器。
2）解析与填充符号表过程，包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;词法、语法分析。将源代码的字符流转变为标记集合，构造出抽象语法树。&lt;/li&gt;
&lt;li&gt;填充符号表。产生符号地址和符号信息。
3）插入式注解处理器的注解处理过程。
4）分析与字节码生成过程，包括：&lt;/li&gt;
&lt;li&gt;标注检查。对语法的静态信息进行检查。&lt;/li&gt;
&lt;li&gt;数据流及控制流分析。对程序动态运行过程进行检查。&lt;/li&gt;
&lt;li&gt;解语法糖。将简化代码编写的语法糖还原为原有的形式。&lt;/li&gt;
&lt;li&gt;字节码生成。将前面各个步骤所生成的信息转化成字节码。&lt;/li&gt;
&lt;/ul&gt;
</description>
                
                
                
                    
                    
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/">tech</category>
                            
                        
                    
                
                
                
                    
                        
                    
                
            </item>
        
            <item>
                <title>排序算法的实现</title>
                <link>https://sslouis.com/tech/fa/</link>
                <guid isPermaLink="true">https://sslouis.com/tech/fa/</guid>
                <pubDate>Thu, 03 Sep 2020 13:12:27 &#43;0800</pubDate>
                
                    <author>sslouis22@gmail.com (sslouis)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description></description>
                
                
                
                    
                    
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/">tech</category>
                            
                        
                    
                
                
                
                    
                        
                    
                
            </item>
        
            <item>
                <title>JVM的类加载</title>
                <link>https://sslouis.com/tech/jvm/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</link>
                <guid isPermaLink="true">https://sslouis.com/tech/jvm/%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</guid>
                <pubDate>Sun, 16 Aug 2020 21:30:32 &#43;0800</pubDate>
                
                    <author>sslouis22@gmail.com (sslouis)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h3 id=&#34;一类加载的时机&#34;&gt;一.类加载的时机&lt;/h3&gt;
&lt;p&gt;一个类型从被加载到虚拟机内存中开始，到卸载出内存位置，它的整个生命周期将会经历加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段。其中验证、准备、解析三部分统称为连接（Linking）。&lt;br&gt;
1）有且只有六种情况必须对类进行&amp;quot;初始化&amp;quot;。&lt;/p&gt;
&lt;h3 id=&#34;二类加载的过程&#34;&gt;二.类加载的过程&lt;/h3&gt;
&lt;h4 id=&#34;1加载&#34;&gt;1.加载&lt;/h4&gt;
&lt;p&gt;1）通过一个类的全限定名来获取定义此类的二进制字节流。&lt;br&gt;
2）将这个字节流所代表的的静态 存储结构转化为方法区的运行时数据结构。&lt;br&gt;
3）在内存中生成一个代表这个类的java.lang.class对象，作为方法区这个类的各种数据的访问入口。&lt;br&gt;
对于数组类而言，情况有所不同。（待补充）&lt;/p&gt;
&lt;h4 id=&#34;2验证&#34;&gt;2.验证&lt;/h4&gt;
&lt;p&gt;这一阶段的目的是确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束条件，保证这些信息被当做代码运行后不会威海虚拟机自身的安全。&lt;br&gt;
验证阶段大致会完成下面四个阶段的检验动作：文件格式验证、元数据验证、字节码验证和符号引用验证。&lt;br&gt;
1）文件格式验证&lt;br&gt;
该阶段的主要目的是保证输入的字节流能正确地解析并存储于方法区之内，格式上符合描述一个Java类型信息的要求。后面的三个验证阶段全部是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。&lt;br&gt;
2）元数据验证&lt;br&gt;
该阶段主要对类的元数据信息进行语义校验。&lt;br&gt;
3）字节码验证&lt;br&gt;
通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的。
JDK6之后的Javac编译器和Java虚拟机里进行了一项联合优化，把尽可能多的校验辅助措施挪到Javac编译器里进行。具体做法是给方法体Code属性的属性表中新增了一项名为&amp;quot;stackMapTable&amp;quot;的新属性，描述了方法体所有的基本块。&lt;br&gt;
4）符号引用验证
对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验，通俗来说，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源。&lt;/p&gt;
&lt;h4 id=&#34;3准备&#34;&gt;3.准备&lt;/h4&gt;
&lt;p&gt;准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段。（初始值是数据类型的零值，赋值要到类的初始化阶段才会被执行，但是ConstantValue除外）。&lt;/p&gt;
&lt;h4 id=&#34;4解析&#34;&gt;4.解析&lt;/h4&gt;
&lt;p&gt;Java虚拟机将常量池内的符号引用替换为直接引用的过程。（符号引用和直接引用的概念）&lt;br&gt;
1）类或接口的解析
2）字段解析
3）方法解析
4）接口方法解析&lt;/p&gt;
&lt;h4 id=&#34;5初始化&#34;&gt;5.初始化&lt;/h4&gt;
&lt;p&gt;初始化变量和其他资源，初始化阶段就是执行类构造器&lt;clinit&gt;()方法的过程。&lt;/p&gt;
&lt;h5 id=&#34;1clinit方法&#34;&gt;1.&amp;lt;clinit&amp;gt;()方法&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;它是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。&lt;/li&gt;
&lt;li&gt;Java虚拟机会保证在子类的&amp;lt;clinit&amp;gt;（）方法执行前，父类的&amp;lt;clinit&amp;gt;（）方法已经执行完毕。&lt;/li&gt;
&lt;li&gt;由于父类的&amp;lt;clinit&amp;gt;（）方法先执行，父类中定义的静态语句块要优先于子类的变量赋值操作。&lt;/li&gt;
&lt;li&gt;&amp;lt;clinit&amp;gt;（）方法不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为这个类生成&lt;clinit&gt;（）方法。&lt;/li&gt;
&lt;li&gt;执行接口的&amp;lt;clinit&amp;gt;（）方法方法不需要先执行父接口的&amp;lt;clinit&amp;gt;（）方法，接口的实现类在初始化时也一样不会执行接口的&amp;lt;clinit&amp;gt;（）方法。&lt;/li&gt;
&lt;li&gt;Java虚拟机必须保证一个类的&amp;lt;clinit&amp;gt;（）方法在多线程环境下被正确地加锁同步。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;三类加载器&#34;&gt;三.类加载器&lt;/h3&gt;
&lt;h4 id=&#34;1类与类加载器&#34;&gt;1.类与类加载器&lt;/h4&gt;
&lt;p&gt;对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。&lt;/p&gt;
&lt;h4 id=&#34;2双亲委派模型&#34;&gt;2.双亲委派模型&lt;/h4&gt;
&lt;p&gt;站在Java虚拟机的角度来看，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），是虚拟机自身的一部分；另外一种就是其他的所有的类加载器，这些类加载器都由Java语言实现，独立存在于虚拟机外部，并且全都继承自抽象类java.lang.CLassLoader。&lt;br&gt;
Java一直保持着三层类加载器、双亲委派的类加载架构。
3个系统提供的类加载器来进行加载：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;启动类加载器（Bootstrap Class Loader）&lt;/li&gt;
&lt;li&gt;扩展类加载器（Extension Class Loader）：&lt;br&gt;
这个类加载器是在类sun.misc.Launcher$ExtClassLoader中以Java代码的形式实现的。它负载加载&amp;lt;JAVA_HOME&amp;gt;\lib\ext目录中，或者被java.ext.dirs系统变量所制定的路径中所有的类库。&lt;/li&gt;
&lt;li&gt;应用程序类加载器（Application Class Loader）:&lt;br&gt;
它负责加载用户类路径（ClassPath）上所有的类库，可以再代码中使用这个类加载器。如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;双亲委派模型&#34;&gt;双亲委派模型&lt;/h5&gt;
&lt;p&gt;双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。父子关系不是以继承关系来实现的，而是通常使用组合关系来复用父加载器的代码。&lt;br&gt;
双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。&lt;/p&gt;
&lt;h4 id=&#34;3破坏双亲委派模型&#34;&gt;3.破坏双亲委派模型&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;第一次被破坏&lt;/li&gt;
&lt;li&gt;第二次被破坏&lt;br&gt;
如果有基础类型又要调用回用户的代码。&lt;br&gt;
引入线程上下文类加载器（Thread Context ClassLoader）,通过该类父类加载器去请求子类加载器完成加载的行为。&lt;/li&gt;
&lt;li&gt;第三次被破坏
热部署，OSGi通过类加载器实现热部署。&lt;/li&gt;
&lt;/ul&gt;
</description>
                
                
                
                    
                    
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/">tech</category>
                            
                        
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/jvm/">JVM</category>
                            
                        
                    
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://sslouis.com/tags/jvm/">JVM</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>JVM的内存模型</title>
                <link>https://sslouis.com/tech/jvm/jvm%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</link>
                <guid isPermaLink="true">https://sslouis.com/tech/jvm/jvm%E7%9A%84%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</guid>
                <pubDate>Mon, 03 Aug 2020 00:00:00 &#43;0800</pubDate>
                
                    <author>sslouis22@gmail.com (sslouis)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;blockquote&gt;
&lt;p&gt;介绍JVM中各个区域的作用、服务对象&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;jvm内存模型&#34;&gt;JVM内存模型&lt;/h2&gt;
&lt;h3 id=&#34;程序计数器&#34;&gt;程序计数器&lt;/h3&gt;
&lt;h3 id=&#34;java虚拟机栈&#34;&gt;Java虚拟机栈&lt;/h3&gt;
&lt;p&gt;###本地方法栈&lt;/p&gt;
&lt;h3 id=&#34;java堆&#34;&gt;Java堆&lt;/h3&gt;
&lt;p&gt;Java堆唯一目的是存放对象实例，它也是垃圾收集器管理的内存区域。&lt;/p&gt;
&lt;h3 id=&#34;方法区method-area&#34;&gt;方法区（Method Area）&lt;/h3&gt;
&lt;h3 id=&#34;运行时常量池&#34;&gt;运行时常量池&lt;/h3&gt;
&lt;h3 id=&#34;直接内存&#34;&gt;直接内存&lt;/h3&gt;
&lt;h2 id=&#34;垃圾收集算法&#34;&gt;垃圾收集算法&lt;/h2&gt;
&lt;h3 id=&#34;引用计数算法&#34;&gt;引用计数算法&lt;/h3&gt;
&lt;h3 id=&#34;可达性分析算法&#34;&gt;可达性分析算法&lt;/h3&gt;
&lt;p&gt;通过一系列称为&amp;quot;GC Roots&amp;quot;的根对象作为起始节点集，从这些节点开始，根据引用关系项下搜索，
搜索过程所走过的路径称为&amp;quot;引用链&amp;quot;，如果某个对象到GC Roots间没有任何引用链项链，
或者用图论的话来说就是GC Roots到这个对象不可达时，则证明此对象是不可能再被使用的。&lt;/p&gt;
&lt;h4 id=&#34;强引用软引用弱引用虚引用&#34;&gt;强引用，软引用，弱引用，虚引用&lt;/h4&gt;
&lt;h3 id=&#34;方法区的回收&#34;&gt;方法区的回收&lt;/h3&gt;
&lt;p&gt;主要回收废弃的常量和不再使用的类型。&lt;/p&gt;
&lt;h3 id=&#34;分代收集理论&#34;&gt;分代收集理论&lt;/h3&gt;
&lt;h3 id=&#34;标记-清除算法&#34;&gt;标记-清除算法&lt;/h3&gt;
&lt;h3 id=&#34;标记-复制算法&#34;&gt;标记-复制算法&lt;/h3&gt;
&lt;h3 id=&#34;标记-整理算法&#34;&gt;标记-整理算法&lt;/h3&gt;
&lt;p&gt;##HotSpot的算法细节实现
###前置知识
####根节点枚举
枚举根节点必须是要停顿的。&lt;br&gt;
在HotSpot中使用OopMap的数据结构来获取对象引用的位置
####安全点
####安全区域&lt;/p&gt;
&lt;h2 id=&#34;经典垃圾收集器&#34;&gt;经典垃圾收集器&lt;/h2&gt;
&lt;h3 id=&#34;1serial收集器&#34;&gt;1.Serial收集器&lt;/h3&gt;
&lt;p&gt;它是新生代收集器，它在进行垃圾收集时，必须暂停其他所有工作线程。&lt;br&gt;
简单高效。&lt;/p&gt;
&lt;h3 id=&#34;2parnew收集器&#34;&gt;2.ParNew收集器&lt;/h3&gt;
&lt;p&gt;它是Serial收集器的多线程并行版本，一般与CMS收集器配合工作。&lt;/p&gt;
&lt;h3 id=&#34;3parallel-scavenge收集器pærəlel-skævɪndʒ&#34;&gt;3.Parallel Scavenge收集器（/&#39;pærəlel/ /&#39;skævɪn(d)ʒ/）&lt;/h3&gt;
&lt;p&gt;它是新生代收集器，主要关注于达到一个可控制的吞吐量。&lt;/p&gt;
&lt;h3 id=&#34;4serial-old收集器&#34;&gt;4.Serial Old收集器&lt;/h3&gt;
&lt;p&gt;它是Serial收集器的老年代版本，使用标记-整理算法。&lt;/p&gt;
&lt;h3 id=&#34;5parallel-old收集器&#34;&gt;5.Parallel Old收集器&lt;/h3&gt;
&lt;h3 id=&#34;6cms收集器&#34;&gt;6.CMS收集器&lt;/h3&gt;
&lt;p&gt;它是一种以获取最短回收停顿时间为目标的收集器。&lt;/p&gt;
&lt;h4 id=&#34;运作过程&#34;&gt;运作过程：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;初始标记&lt;/li&gt;
&lt;li&gt;并发标记&lt;/li&gt;
&lt;li&gt;重新标记&lt;/li&gt;
&lt;li&gt;并发清除&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;缺点&#34;&gt;缺点：&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;li&gt;空间碎片过多。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;7garbage-first收集器&#34;&gt;7.Garbage First收集器&lt;/h3&gt;
&lt;h2 id=&#34;内存分配与回收策略&#34;&gt;内存分配与回收策略&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;1.对象优先在Eden分配&lt;/li&gt;
&lt;li&gt;2.大对象直接进入老年代&lt;/li&gt;
&lt;li&gt;3.长期存活的对象将进入老年代&lt;/li&gt;
&lt;li&gt;4.动态对象年龄判定&lt;br&gt;
如果在Survivor空间中低于或等于某年龄的所有对象大小的总和大于Survivor空间的一半，
年龄大于或等于该年龄的对啊ing就可以直接进入老年代。&lt;/li&gt;
&lt;li&gt;5.空间分配担保&lt;/li&gt;
&lt;/ul&gt;
</description>
                
                
                
                    
                    
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/">tech</category>
                            
                        
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/jvm/">JVM</category>
                            
                        
                    
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://sslouis.com/tags/jvm/">JVM</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Spring事务传播机制</title>
                <link>https://sslouis.com/tech/spring/spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6/</link>
                <guid isPermaLink="true">https://sslouis.com/tech/spring/spring%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6/</guid>
                <pubDate>Tue, 30 Jun 2020 12:43:32 &#43;0800</pubDate>
                
                    <author>sslouis22@gmail.com (sslouis)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;p&gt;Spring对事务控制的支持同意在TransactionDefinition类中描述&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;int getPropagationBehavior():事务的传播行为&lt;/li&gt;
&lt;li&gt;int getIsolationLevel():事务的隔离级别&lt;/li&gt;
&lt;li&gt;int getTimeout():事务的过期时间&lt;/li&gt;
&lt;li&gt;boolean isReadOnly():事务的读/写特性&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;spring支持7种事务传播行为默认的事务传播行为是propagation_required如果当前没有事务就新建一个事务如果已经存在一个事务就加入到这个事务中&#34;&gt;Spring支持7种事务传播行为,默认的事务传播行为是PROPAGATION_REQUIRED,如果当前没有事务,就新建一个事务;如果已经存在一个事务,就加入到这个事务中.&lt;/h4&gt;
&lt;h4 id=&#34;在spring中dao通过threadlocal将由状态的变量如connection等本地线程化从而实现线程安全&#34;&gt;在Spring中,DAO通过ThreadLocal将由状态的变量(如Connection等)本地线程化,从而实现线程安全&lt;/h4&gt;
&lt;h4 id=&#34;在相同线程中进行相互嵌套调用的事务方法工作在相同的事务中如果这些相互嵌套调用的方法工作在不同的线程中则不同线程下的事务方法工作在独立的事务中&#34;&gt;在相同线程中进行相互嵌套调用的事务方法工作在相同的事务中.如果这些相互嵌套调用的方法工作在不同的线程中,则不同线程下的事务方法工作在独立的事务中.&lt;/h4&gt;
&lt;h4 id=&#34;哪些方法不能实施spring-aop事务失效&#34;&gt;哪些方法不能实施Spring AOP(事务失效)&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;由于接口的方法都必须是public的,实现类的实现方法必须是public的(不能是protected,private等),同时不能使用static修饰符.&lt;/li&gt;
&lt;li&gt;基于CGLib字节码动态代理的方案是通过扩展被增强类,动态创建其子类的方式进行AOP增强植入的.由于使用final,static,private修饰符的方法都不能被子类覆盖,相应的这些方法将无法实施AOP增强.&lt;/li&gt;
&lt;li&gt;这些方法只要被外层的事务方法调用了,由于Spring事务管理的传播级别,内部方法也可以工作在外部方法所启动的事务上下文中&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数据连接泄露&#34;&gt;数据连接泄露&lt;/h3&gt;
&lt;p&gt;只要程序使用Spring DAO模板进行数据访问,就一定不会存在数据连接泄露的问题&lt;/p&gt;
</description>
                
                
                
                    
                    
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/">tech</category>
                            
                        
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/spring/">Spring</category>
                            
                        
                    
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://sslouis.com/tags/spring/">Spring</category>
                                
                            
                                
                                
                                
                                    <category domain="https://sslouis.com/tags/%E4%BA%8B%E5%8A%A1/">事务</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Spring事务管理</title>
                <link>https://sslouis.com/tech/spring/spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</link>
                <guid isPermaLink="true">https://sslouis.com/tech/spring/spring%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</guid>
                <pubDate>Sun, 28 Jun 2020 20:23:22 &#43;0800</pubDate>
                
                    <author>sslouis22@gmail.com (sslouis)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h3 id=&#34;数据库事务的4个特性&#34;&gt;数据库事务的4个特性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;原子性(Atomic)&lt;/li&gt;
&lt;li&gt;一致性(Consistency)&lt;/li&gt;
&lt;li&gt;隔离性(Isolation)&lt;/li&gt;
&lt;li&gt;持久性(Durabiliy)&lt;br&gt;
简称ACID.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数据库隔离级别&#34;&gt;数据库隔离级别&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;READ UNCOMMITTED(未提交读)&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数据库并发问题&#34;&gt;数据库并发问题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;脏读(dirty read)&lt;br&gt;
A事务读取B事务尚未提交的更改数据,并在这个数据的基础上进行操作.如果恰巧B事务回滚,那么A事务读到的数据根本是不被承认的.&lt;/li&gt;
&lt;li&gt;不可重复读(unrepeatable read)&lt;br&gt;
指A事务读取了B事务已经提交的更改数据.(更改数据,行级锁)&lt;/li&gt;
&lt;li&gt;幻象读(plantom read)&lt;br&gt;
A事务读取B事务提交的新增数据,这时A事务将出现幻象读的问题.(新增数据,表级锁)&lt;/li&gt;
&lt;li&gt;第一类丢失更新&lt;br&gt;
A事务撤销时,把已经提交的B事务的更新数据覆盖了.&lt;/li&gt;
&lt;li&gt;第二类丢失更新&lt;br&gt;
A事务覆盖B事务已经提交的数据,造成B事务所做操作丢失.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数据库锁机制&#34;&gt;数据库锁机制&lt;/h3&gt;
&lt;p&gt;通过锁机制解决并发访问的问题,按锁定的对象不同,一般可以分为表锁定和行锁定.&lt;br&gt;
从并发事务锁定的关系上看,可以分为共享锁定和独占锁定.共享锁定会防止独占锁定,但允许其他的共享锁定,而独占锁定既防止其他的独占锁定,也防止其他的共享锁定.&lt;br&gt;
为了更改数据,数据库必须在进行更改的行上施加行独占锁定,INSERT,UPDATE,DELETE和SELECT FOR UPDATE语句都会隐式采用必要的行锁定.&lt;br&gt;
事务的隔离级别和数据库并发性是对立的.&lt;/p&gt;
&lt;h3 id=&#34;threadlocal&#34;&gt;ThreadLocal&lt;/h3&gt;
&lt;p&gt;它是保存线程本地化对象的容器.&lt;br&gt;
当运行于多线程环境的某个对象使用ThreadLocal维护变量时,ThreadLocal为每个使用该变量的线程分配一个独立的变量副本.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;void set(Object value):设置当前线程的线程局部变量的值.&lt;/li&gt;
&lt;li&gt;public Object get():返回当前线程所对应的线程局部变量.&lt;/li&gt;
&lt;li&gt;public void remove():将当前线程局部变量的值删除.&lt;/li&gt;
&lt;li&gt;protected Object initialValue():返回该线程局部变量的初始值.&lt;br&gt;
ThreadLocal中一个Map,用于存储每个线程的变量副本,Map中元素的键为线程对象,值为对应线程的变量副本.&lt;br&gt;
同步机制:访问串行化,对象共享化;ThreadLocal:访问并行化,对象共享化.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;使用注解配置声明式事务&#34;&gt;使用注解配置声明式事务&lt;/h3&gt;
&lt;h4 id=&#34;使用transactional注解&#34;&gt;使用@Transactional注解&lt;/h4&gt;
&lt;p&gt;proxy-target-class:如果为true,则Spring将通过创建子类来代理业务类;如果为false,则使用基于接口的代理.如果使用子类代理,则需要在类路径中添加CGLib.jar类库.&lt;br&gt;
默认属性值:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务传播行为:PROPAGATION_REQUIRED&lt;/li&gt;
&lt;li&gt;事务隔离级别:ISOLATION_DEFAULT&lt;/li&gt;
&lt;li&gt;读写事务属性:读/写事务&lt;/li&gt;
&lt;li&gt;超时时间:依赖于底层的事务系统的默认值.&lt;/li&gt;
&lt;li&gt;回滚设置:任何运行期异常引发回滚,任何检查型异常不会引发回滚.&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;建议在业务实现类上使用transactional注解&#34;&gt;建议在业务实现类上使用@Transactional注解&lt;/h4&gt;
&lt;h3 id=&#34;死锁&#34;&gt;死锁&lt;/h3&gt;
</description>
                
                
                
                    
                    
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/">tech</category>
                            
                        
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/spring/">Spring</category>
                            
                        
                    
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://sslouis.com/tags/spring/">Spring</category>
                                
                            
                                
                                
                                
                                    <category domain="https://sslouis.com/tags/%E4%BA%8B%E5%8A%A1/">事务</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Spring MVC</title>
                <link>https://sslouis.com/tech/spring/spring-mvc/</link>
                <guid isPermaLink="true">https://sslouis.com/tech/spring/spring-mvc/</guid>
                <pubDate>Mon, 23 Mar 2020 23:53:12 &#43;0800</pubDate>
                
                    <author>sslouis22@gmail.com (sslouis)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h4 id=&#34;heading&#34;&gt;&lt;/h4&gt;
&lt;p&gt;Spring MVC框架围绕DispatcherServlet核心展开，它负责截获请求并将其分派给相应的处理器处理。&lt;br&gt;
Spring MVC框架包括注解驱动控制器、请求及响应的信息处理、视图解析、本地化解析、上传文件解析、异常处理及表单标签绑定等内容。&lt;/p&gt;
</description>
                
                
                
                    
                    
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/">tech</category>
                            
                        
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/spring/">Spring</category>
                            
                        
                    
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://sslouis.com/tags/spring/">Spring</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>HashMap笔记</title>
                <link>https://sslouis.com/tech/spring/hashmap/</link>
                <guid isPermaLink="true">https://sslouis.com/tech/spring/hashmap/</guid>
                <pubDate>Wed, 04 Mar 2020 19:54:43 &#43;0800</pubDate>
                
                    <author>sslouis22@gmail.com (sslouis)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h2 id=&#34;hashmap&#34;&gt;HashMap&lt;/h2&gt;
&lt;h3 id=&#34;方法&#34;&gt;方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;default V getOrDefault(Object key,V defaultValue)&lt;/code&gt;
可以返回默认值defaultValue&lt;/li&gt;
&lt;/ul&gt;
</description>
                
                
                
                    
                    
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/">tech</category>
                            
                        
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/spring/">Spring</category>
                            
                        
                    
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://sslouis.com/tags/%E7%AE%97%E6%B3%95/">算法</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>在IoC容器中装配Bean</title>
                <link>https://sslouis.com/tech/spring/%E5%9C%A8ioc%E5%AE%B9%E5%99%A8%E4%B8%AD%E8%A3%85%E9%85%8Dbean/</link>
                <guid isPermaLink="true">https://sslouis.com/tech/spring/%E5%9C%A8ioc%E5%AE%B9%E5%99%A8%E4%B8%AD%E8%A3%85%E9%85%8Dbean/</guid>
                <pubDate>Tue, 03 Mar 2020 18:47:47 &#43;0800</pubDate>
                
                    <author>sslouis22@gmail.com (sslouis)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h4 id=&#34;概述&#34;&gt;概述&lt;/h4&gt;
&lt;p&gt;Bean配置信息首先定义了Bean的实现及依赖关系,Spring容器根据各种形式的Bean配置信息在容器内部建立Bean定义注册表;然后根据注册表加载/实例化Bean,并建立Bean和Bean之间的依赖关系;最后将这些准备就绪的Bean放到Bean缓存池中,以供外层的应用程序进行调用.&lt;/p&gt;
&lt;h3 id=&#34;依赖注入&#34;&gt;依赖注入&lt;/h3&gt;
&lt;p&gt;属性注入,构造函数注入&lt;/p&gt;
&lt;h4 id=&#34;属性注入&#34;&gt;属性注入&lt;/h4&gt;
&lt;p&gt;指通过setXxx()方法注入Bean的属性值或依赖对象,是最常采用的注入方式.&lt;br&gt;
属性注入要求Bean提供一个默认的构造函数,并为需要注入的属性提供对应的Setter方法.&lt;br&gt;
Sring先调用Bean的默认构造函数实例化Bean对象,然后通过反射的方式调用Setter方法注入属性值.&lt;br&gt;
需要注入变量名的大小写问题.&lt;/p&gt;
&lt;h4 id=&#34;构造函数注入&#34;&gt;构造函数注入&lt;/h4&gt;
&lt;p&gt;使用构造函数的前提是Bean必须提供带参的构造函数.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;按类型匹配入参&lt;/li&gt;
&lt;li&gt;按索引匹配入参&lt;/li&gt;
&lt;li&gt;联合使用类型和索引匹配入参&lt;/li&gt;
&lt;li&gt;通过自身类型反射匹配入参&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;循环依赖问题&#34;&gt;循环依赖问题&lt;/h4&gt;
&lt;p&gt;如果两个Bean都采用构造函数注入,而且都通过构造函数入参引用对方,就会发生循环依赖问题.&lt;br&gt;
解决:将构造函数注入方式改为属性注入方式.&lt;/p&gt;
&lt;h4 id=&#34;工厂方法注入&#34;&gt;工厂方法注入&lt;/h4&gt;
&lt;h5 id=&#34;非静态工厂方法&#34;&gt;非静态工厂方法&lt;/h5&gt;
&lt;p&gt;工厂类对外屏蔽了目标类的实例化步骤,调用者甚至无需知道具体的目标类是什么&lt;/p&gt;
&lt;h5 id=&#34;静态工厂方法&#34;&gt;静态工厂方法&lt;/h5&gt;
&lt;h4 id=&#34;bean作用域&#34;&gt;Bean作用域&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;singleton 在Spring Ioc容器中仅存在一个Bean实例,Bean以单实例的方式存在&lt;/li&gt;
&lt;li&gt;prototype 每次在容器中调用Bean时,都返回一个新的实例&lt;/li&gt;
&lt;li&gt;request 每次HTTP请求都会创建一个新的Bean,仅适用于WebApplicationContext&lt;/li&gt;
&lt;li&gt;session 同一个HTTP Session共享一个Bean,仅适用于WebApplicationContext&lt;/li&gt;
&lt;li&gt;globalSession 同一个全局Session共享一个Bean&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;基于注解的配置&#34;&gt;基于注解的配置&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;@Component&lt;/li&gt;
&lt;li&gt;@Repository&lt;/li&gt;
&lt;li&gt;@Service&lt;/li&gt;
&lt;li&gt;@Controller&lt;/li&gt;
&lt;/ul&gt;
&lt;h5 id=&#34;扫描注解定义的bean&#34;&gt;扫描注解定义的Bean&lt;/h5&gt;
&lt;h5 id=&#34;自动装配bean&#34;&gt;自动装配Bean&lt;/h5&gt;
&lt;ul&gt;
&lt;li&gt;使用@Autowired进行自动注入&lt;br&gt;
可以使用@Autowired(required=false)避免抛出异常&lt;br&gt;
通过@Qualifier(&amp;quot;xx&amp;quot;)匹配限定Bean&lt;br&gt;
可以对类成员变量及方法的入参进行标注&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;@Autowired
public void setLogDao(LogDao logDao){
    this.logDao = logDao;
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一般建议在方法上标注@Autowired注解&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;@Resource按名称匹配注入&lt;/li&gt;
&lt;li&gt;@Scope注解可以指定Bean的作用范围&lt;/li&gt;
&lt;li&gt;@PostConstruct和@PreDstroy注解可以用在类方法上&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;基于java类的配置&#34;&gt;基于Java类的配置&lt;/h4&gt;
&lt;p&gt;@Configuration,可以为Spring容器提供Bean定义的信息&lt;/p&gt;
</description>
                
                
                
                    
                    
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/">tech</category>
                            
                        
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/spring/">Spring</category>
                            
                        
                    
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://sslouis.com/tags/spring/">Spring</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>TreeMap笔记</title>
                <link>https://sslouis.com/tech/spring/treemap/</link>
                <guid isPermaLink="true">https://sslouis.com/tech/spring/treemap/</guid>
                <pubDate>Thu, 13 Feb 2020 00:00:00 &#43;0800</pubDate>
                
                    <author>sslouis22@gmail.com (sslouis)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h2 id=&#34;treemap&#34;&gt;TreeMap&lt;/h2&gt;
</description>
                
                
                
                    
                    
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/">tech</category>
                            
                        
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/spring/">Spring</category>
                            
                        
                    
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://sslouis.com/tags/java-collections/">Java Collections</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>IoC原理</title>
                <link>https://sslouis.com/tech/spring/ioc/</link>
                <guid isPermaLink="true">https://sslouis.com/tech/spring/ioc/</guid>
                <pubDate>Fri, 27 Dec 2019 16:22:06 &#43;0800</pubDate>
                
                    <author>sslouis22@gmail.com (sslouis)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h2 id=&#34;beanfactory和applicationcontext和bean&#34;&gt;BeanFactory和ApplicationContext和Bean&lt;/h2&gt;
&lt;h3 id=&#34;某一接口具体实现类的选择控制权从调用类中移除转交给第三方决定即由spring容器借由bean配置来进行控制&#34;&gt;某一接口具体实现类的选择控制权从调用类中移除,转交给第三方决定,即由Spring容器借由Bean配置来进行控制.&lt;/h3&gt;
&lt;h3 id=&#34;类型&#34;&gt;类型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;构造函数注入&lt;/li&gt;
&lt;li&gt;属性注入&lt;/li&gt;
&lt;li&gt;接口注入&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;beanfactory&#34;&gt;BeanFactory&lt;/h3&gt;
&lt;p&gt;通常称为IoC容器,ApplicationContext为应用上下文.
BeanFactory是Spring框架的基础设施,面向Spring本身;ApplicationContext面向使用Spring框架的开发者.
所有可以被Spring容器实例化并管理的Java类都可以成为Bean.&lt;/p&gt;
&lt;h3 id=&#34;applicationcontext&#34;&gt;ApplicationContext&lt;/h3&gt;
&lt;h4 id=&#34;实现类&#34;&gt;实现类&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;CLassPathXmlApplicationContext
&lt;code&gt;ApplicationCOntext ctx = new ClassPathXmlApplicationContext(&amp;quot;com/smart/context/beans.xml&amp;quot;)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;FileSystemXmlApplicationContext&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;applicationcontext在初始化应用上下文时就实例化所有单实例的bean&#34;&gt;ApplicationContext在初始化应用上下文时就实例化所有单实例的Bean.&lt;/h4&gt;
&lt;h4 id=&#34;javaconfig提供了spring基于类注解的配置方式configuration&#34;&gt;JavaConfig提供了Spring基于类注解的配置方式,@Configuration&lt;/h4&gt;
&lt;h4 id=&#34;annotationconfigapplicationcontext&#34;&gt;AnnotationConfigApplicationContext&lt;/h4&gt;
&lt;h4 id=&#34;webapplicationcontext&#34;&gt;WebApplicationContext&lt;/h4&gt;
&lt;p&gt;专门为Web应用准备的,从WebApplicationContext中可以获得ServletContext的引用,整个WEb应用上下文对象将作为属性放置到ServletContext中,以便Web应用环境可以访问Spring应用上下文.&lt;/p&gt;
&lt;h5 id=&#34;webapplicationcontextutils&#34;&gt;WebApplicationContextUtils&lt;/h5&gt;
&lt;h5 id=&#34;为bean添加了三个新的作用域requestsession和global-session&#34;&gt;为Bean添加了三个新的作用域:request,session和global session&lt;/h5&gt;
&lt;h5 id=&#34;定义了一个常量root_web_application_context_attribute在上下文启动时webapplicationcontextcontext实例即以此为键放置在servletcontext的属性列表中&#34;&gt;定义了一个常量ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE,在上下文启动时,WebApplicationContextContext实例即以此为键放置在ServletContext的属性列表中,&lt;/h5&gt;
&lt;h5 id=&#34;webapplicationcontext初始化&#34;&gt;WebApplicationContext初始化&lt;/h5&gt;
&lt;h5 id=&#34;父子容器-hierarchicalbeanfactory&#34;&gt;父子容器 HierarchicalBeanFactory&lt;/h5&gt;
&lt;h3 id=&#34;bean的生命周期&#34;&gt;Bean的生命周期&lt;/h3&gt;
&lt;p&gt;&lt;img src=&#34;&#34; alt=&#34;avatar&#34;&gt;&lt;/p&gt;
&lt;h4 id=&#34;beanpostprocessoraop动态代理的关键&#34;&gt;BeanPostProcessor(AOP,动态代理的关键)&lt;/h4&gt;
&lt;h4 id=&#34;heading&#34;&gt;&lt;/h4&gt;
&lt;p&gt;Bean的作用范围scope=&amp;quot;prototype&amp;quot;时,将Bean返回给调用者,调用者负责Bean后续生命的管理,
scope=&amp;quot;singleton&amp;quot;,将Bean放入Spring Ioc容器的缓存池中,并将Bean引用返回给调用者,Spring继续对这些Bean进行后续的生命管理.&lt;/p&gt;
&lt;h4 id=&#34;bean生命周期中的方法分为4类&#34;&gt;Bean生命周期中的方法,分为4类&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Bean自身的方法&lt;br&gt;
构造函数,Setter,init-method,destroy-method等&lt;/li&gt;
&lt;li&gt;Bean级生命周期接口方法&lt;br&gt;
BeanNameAware,BeanFactoryAware,InitializingBean,DisposableBean&lt;/li&gt;
&lt;li&gt;容器级生命周期接口方法&lt;/li&gt;
&lt;li&gt;工厂后处理器接口方法&lt;br&gt;
AspectJWeavingEnabler,CustomAutowireConfigurer,ConfigurationCLassPostProcessor&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;applicationcontext会自动识别postprocessor而beanfactory需要手动调用addbeanpostprocessor&#34;&gt;ApplicationContext会自动识别POstProcessor,而BeanFactory需要手动调用addBeanPostProcessor()&lt;/h4&gt;
</description>
                
                
                
                    
                    
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/">tech</category>
                            
                        
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/spring/">Spring</category>
                            
                        
                    
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://sslouis.com/tags/spring/">Spring</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Spring Boot</title>
                <link>https://sslouis.com/tech/spring/spring-boot/</link>
                <guid isPermaLink="true">https://sslouis.com/tech/spring/spring-boot/</guid>
                <pubDate>Fri, 09 Aug 2019 00:00:00 &#43;0800</pubDate>
                
                    <author>sslouis22@gmail.com (sslouis)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h2 id=&#34;spring-boot&#34;&gt;Spring Boot&lt;/h2&gt;
&lt;h3 id=&#34;起步依赖&#34;&gt;起步依赖&lt;/h3&gt;
&lt;h3 id=&#34;heading&#34;&gt;&lt;/h3&gt;
</description>
                
                
                
                    
                    
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/">tech</category>
                            
                        
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/spring/">Spring</category>
                            
                        
                    
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://sslouis.com/tags/spring/">Spring</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Spring AOP笔记</title>
                <link>https://sslouis.com/tech/spring/aop/</link>
                <guid isPermaLink="true">https://sslouis.com/tech/spring/aop/</guid>
                <pubDate>Sat, 03 Aug 2019 22:00:21 &#43;0800</pubDate>
                
                    <author>sslouis22@gmail.com (sslouis)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h3 id=&#34;spring-aop-面向切面编程&#34;&gt;Spring AOP 面向切面编程&lt;/h3&gt;
&lt;p&gt;适用场景：具有横切逻辑的场景，如性能检测、访问控制、事务管理及日志记录等。&lt;/p&gt;
&lt;h4 id=&#34;术语&#34;&gt;术语&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;连接点（Joinpoint）&lt;br&gt;
一个类或一端程序代码拥有一些具有边界性质的特定点（类初始化后、类的某个方法调用前/调用后、方法抛出异常后）。&lt;/li&gt;
&lt;li&gt;切点（Pointcut）&lt;br&gt;
一个切点可以匹配多个连接点。通过org.springframework.aop.Pointcut接口进行描述，它使用类和方法作为连接点的查询条件，Spring AOP的规则解析引擎负责解析切点所设定的查询条件，找到对应的连接点。&lt;/li&gt;
&lt;li&gt;增强（Advice）&lt;br&gt;
增强是织入目标类连接点上的一端程序代码。&lt;/li&gt;
&lt;li&gt;目标对象（Target）&lt;/li&gt;
&lt;li&gt;引介（Introduction）&lt;br&gt;
它为类添加一些属性和方法。&lt;/li&gt;
&lt;li&gt;织入（Weaving）&lt;br&gt;
织入是将增强添加到目标类的具体连接点上过程。&lt;br&gt;
1）编译期织入。
2）类装载期织入。
3）动态代理织入。&lt;br&gt;
Spring采用动态代理织入，AspectJ采用编译期织入和类装载期织入。&lt;/li&gt;
&lt;li&gt;代理（Proxy）&lt;/li&gt;
&lt;li&gt;切面（Aspect）&lt;br&gt;
切面由切点和增强（引介）组成。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;jdk动态代理&#34;&gt;JDK动态代理&lt;/h4&gt;
&lt;p&gt;主要用到两个类，Proxy和InvocationHandler。&lt;/p&gt;
&lt;h4 id=&#34;cglib动态代理&#34;&gt;CGLib动态代理&lt;/h4&gt;
&lt;p&gt;通过创建子类的方式生成代理对象，不能对目标类中的final或private方法进行代理。&lt;/p&gt;
</description>
                
                
                
                    
                    
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/">tech</category>
                            
                        
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/spring/">Spring</category>
                            
                        
                    
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://sslouis.com/tags/spring/">Spring</category>
                                
                            
                                
                                
                                
                                    <category domain="https://sslouis.com/tags/java/">Java</category>
                                
                            
                                
                                
                                
                                    <category domain="https://sslouis.com/tags/aop/">AOP</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>雪花算法</title>
                <link>https://sslouis.com/tech/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/</link>
                <guid isPermaLink="true">https://sslouis.com/tech/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/</guid>
                <pubDate>Sat, 27 Jul 2019 09:47:32 &#43;0800</pubDate>
                
                    <author>sslouis22@gmail.com (sslouis)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h4 id=&#34;特点&#34;&gt;特点&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;能满足高并发分布式系统环境下ID不重复&lt;/li&gt;
&lt;li&gt;基于时间戳，可以保证基本有序递增&lt;/li&gt;
&lt;li&gt;不依赖第三方的库或者中间件&lt;/li&gt;
&lt;li&gt;生成效率极高&lt;/li&gt;
&lt;/ul&gt;
</description>
                
                
                
                    
                    
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/">tech</category>
                            
                        
                    
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://sslouis.com/tags/%E7%AE%97%E6%B3%95/">算法</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Electron的坑</title>
                <link>https://sslouis.com/tech/web/electron%E7%9A%84%E5%9D%91/</link>
                <guid isPermaLink="true">https://sslouis.com/tech/web/electron%E7%9A%84%E5%9D%91/</guid>
                <pubDate>Thu, 06 Jun 2019 00:00:00 &#43;0800</pubDate>
                
                    <author>sslouis22@gmail.com (sslouis)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h3 id=&#34;1node-installjs卡住&#34;&gt;1.node install.js卡住&lt;/h3&gt;
&lt;p&gt;可能是网络原因,可以等待或者将npm的下载库改为百度&lt;/p&gt;
&lt;h3 id=&#34;2发生错误-cannot-find-module-app&#34;&gt;2.发生错误 &amp;quot;Cannot find module app&amp;quot;&lt;/h3&gt;
&lt;p&gt;原代码长这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;var app = require(&#39;app&#39;);
var BrowserWindow = require(&#39;browser-window&#39;);
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;修改成:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const electron = require(&#39;electron&#39;);
const app = electron.app;
const BrowserWindow = electron.BrowserWindow;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;参考:&lt;code&gt;https://stackoverflow.com/questions/39683163/cannot-find-module-app-when-trying-to-run-electron-app&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;3loadurl报错&#34;&gt;3.loadUrl报错&lt;/h3&gt;
&lt;p&gt;修改成&lt;code&gt;loadURL()&lt;/code&gt;
参考:https://stackoverflow.com/questions/37614054/loadurl-is-not-working-in-electron&lt;/p&gt;
</description>
                
                
                
                    
                    
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/">tech</category>
                            
                        
                    
                        
                        
                        
                    
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://sslouis.com/tags/javascript/">JavaScript</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>实现鼠标滑动div的出现和隐藏</title>
                <link>https://sslouis.com/tech/web/%E5%AE%9E%E7%8E%B0%E9%BC%A0%E6%A0%87%E6%BB%91%E5%8A%A8div%E7%9A%84%E5%87%BA%E7%8E%B0%E5%92%8C%E9%9A%90%E8%97%8F/</link>
                <guid isPermaLink="true">https://sslouis.com/tech/web/%E5%AE%9E%E7%8E%B0%E9%BC%A0%E6%A0%87%E6%BB%91%E5%8A%A8div%E7%9A%84%E5%87%BA%E7%8E%B0%E5%92%8C%E9%9A%90%E8%97%8F/</guid>
                <pubDate>Thu, 17 Jan 2019 19:37:22 &#43;0800</pubDate>
                
                    <author>sslouis22@gmail.com (sslouis)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;在工作中遇到需要通过鼠标滑动出现和隐藏菜单栏的功能,经过研究发现可以直接通过css原生方法解决。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;正文&#34;&gt;正文&lt;/h2&gt;
&lt;h5 id=&#34;html和css文件分别如下&#34;&gt;html和css文件分别如下&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;div id=&amp;quot;big&amp;quot;&amp;gt;
	&amp;lt;div id=&amp;quot;small&amp;quot;&amp;gt;
	&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;pre&gt;&lt;code&gt;#big:hover #small{
	&amp;lt;!--鼠标停留在外面div时小div的状态为显示--&amp;gt;
	display:inline-block;
}
#middle{
	display:none;
}
&lt;/code&gt;&lt;/pre&gt;</description>
                
                
                
                    
                    
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/">tech</category>
                            
                        
                    
                        
                        
                        
                    
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://sslouis.com/tags/html/">html</category>
                                
                            
                                
                                
                                
                                    <category domain="https://sslouis.com/tags/css/">css</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title>Hello World</title>
                <link>https://sslouis.com/life/hello-world/</link>
                <guid isPermaLink="true">https://sslouis.com/life/hello-world/</guid>
                <pubDate>Sat, 15 Dec 2018 18:47:47 &#43;0800</pubDate>
                
                    <author>sslouis22@gmail.com (sslouis)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;p&gt;这里用来测试各种奇奇怪怪的东西。&lt;/p&gt;
&lt;p&gt;&lt;img src=&#34;https://sslouis.com/mstile-150x150.png&#34; alt=&#34;Hugo使用图片资源&#34;&gt;&lt;/p&gt;
</description>
                
                
                
                    
                    
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/life/">life</category>
                            
                        
                    
                
                
                
                    
                        
                    
                
            </item>
        
            <item>
                <title>红黑树</title>
                <link>https://sslouis.com/tech/%E7%AE%97%E6%B3%95/%E7%BA%A2%E9%BB%91%E6%A0%91/</link>
                <guid isPermaLink="true">https://sslouis.com/tech/%E7%AE%97%E6%B3%95/%E7%BA%A2%E9%BB%91%E6%A0%91/</guid>
                <pubDate>Thu, 13 Sep 2018 00:00:00 &#43;0800</pubDate>
                
                    <author>sslouis22@gmail.com (sslouis)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;p&gt;1.特点:
1.1节点都有颜色.
1.2在插入和删除的过程中,要遵循保持这些颜色的不同排列的规则.
2.红黑规则:
2.1每一个节点不是红色的就是黑色的.
2.2根总是黑色的.
2.3如果节点是红色的,则它的子节点必须是黑色的(反之倒不一定必须为真).
2.4从根到叶节点或空子节点的每条路径,必须包含相同数目的黑色节点.
(空子节点是指非叶节点本可能有,但实际上没有的那个子节点)
3.修正违规的情况 &lt;br&gt;
3.1改变节点的颜色.
3.2执行旋转操作.
4.旋转
4.1目的:使一些节点上升,一些节点下降,帮助树平衡. &lt;br&gt;
保证不破坏二叉搜索树的特征.
4.2简单旋转
选择一个节点作为旋转的顶端,如果做一次右旋,这个顶端节点将会向下和向右移动到它右子节点的为止.
它的左子节点将会上移到它原来的位置上. &lt;br&gt;
如果做右旋,顶端节点必须有一个左子节点.做左旋,顶端节点必须有一个右子节点.
5.插入一个新节点
5.1在下行路途中的颜色变换
规则:每当查找例程遇到一个有两个红色子节点的黑色节点时,它必须把子节点变为黑色,而把父节点变为红色(除非父节点为根结点,根总是黑色的)
5.2插入节点之后的旋转
X是一个特殊的节点,P是X的父,G是X的祖父节点(P的父节点).
首先,插入的节点总是红色的
概念:内侧子孙,外侧子孙
5.2.1分三种情况讨论
0.1P是黑色的:不违反规则,插入完成.
0.2P是红色的,X是G的一个外侧子孙节点.
改变X的祖父节点G的颜色,改变X的父节点P的颜色,以X的祖父节点G为顶旋转.
0.3P是红色的,X是G的一个内侧子孙节点.
改变X的祖父节点的颜色,改变X的颜色,用X的父节点作为顶旋转,向X上升的方向旋转,再以X的祖父节点为顶旋转,向X上升的方向旋转.
在下行路途中的颜色变换消除了旋转造成树的上方任何规则的违规情况.
6.删除
删除过程非常复杂,一般情况下为删除的节点做标记而不实际地删除它.
7.AVL树
AVL树中每个节点存储一个额外的数据:它的左子树和右子树的高度差.这个差值不会大于1.
插入之后,检查新节点插入点所在的最低子树的根,如果它的子节点的高度相差大于1,执行一次或者两次旋转使它们的高度相等,然后算法向上移动,检查上面的节点,必要时均衡高度,这次检测检查所有路径一直向上,直到根位置.
AVL树查找的时间复杂度为O(logN),因为树一定是平衡的,但是,由于插入(或删除)一个节点时需要扫描两趟树,一次向下查找插入点,一次向上平衡树,AVL树不如红-黑树效率高,也不如红-黑树常用.&lt;/p&gt;
</description>
                
                
                
                    
                    
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/">tech</category>
                            
                        
                    
                        
                        
                        
                    
                
                
                
                    
                        
                            
                                
                                
                                
                                    <category domain="https://sslouis.com/tags/%E7%AE%97%E6%B3%95/">算法</category>
                                
                            
                        
                    
                
            </item>
        
            <item>
                <title></title>
                <link>https://sslouis.com/tech/web/%E8%B7%B3%E8%A1%A8/</link>
                <guid isPermaLink="true">https://sslouis.com/tech/web/%E8%B7%B3%E8%A1%A8/</guid>
                <pubDate>Mon, 01 Jan 0001 00:00:00 &#43;0000</pubDate>
                
                    <author>sslouis22@gmail.com (sslouis)</author>
                
                <copyright>[CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh)</copyright>
                
                    <description>&lt;p&gt;跳表 | 会跳的链表原来这么diao&lt;/p&gt;
&lt;p&gt;moon聊技术  昨天
以下文章来源于bigsai ，作者bigsai&lt;/p&gt;
&lt;p&gt;bigsai
.
专注于数据结构与算法、Java知识分享，让学习更加简单！
前言&lt;/p&gt;
&lt;p&gt;跳表是面试常问的一种数据结构，它在很多中间件和语言中得到应用，我们最最熟知的就有Redis跳表(zset)。并且在面试的很多场景可能会问到，偶尔还会让你手写试一试(跳表可能会让手写，红黑树是不可能的)，这不，给大伙复原一个场景：&lt;/p&gt;
&lt;p&gt;图片
但你别慌，遇到蘑菇头这种面试官也别怕，因为你看到这篇文章了(得意😏)，不用像熊猫那样窘迫。&lt;/p&gt;
&lt;p&gt;对于一个数据结构或算法，人群数量从听过名称、了解基本原理、清楚执行流程、能够手写 呈抖降的趋势。因为很多数据结构与算法其核心原理可能简单，但清楚其执行流程就需要动脑子去思考想明白，但是如果能够把它写出来，那就要自己一步步去设计和实现。可能要花很久才能真正写出来，并且还可能要查阅大量的资料。&lt;/p&gt;
&lt;p&gt;而本文在前面进行介绍跳表，后面部分详细介绍跳表的设计和实现，搞懂跳表，这一篇真的就够了。&lt;/p&gt;
&lt;p&gt;快速了解跳表&lt;/p&gt;
&lt;p&gt;跳跃表(简称跳表)由美国计算机科学家William Pugh发明于1989年。他在论文《Skip lists: a probabilistic alternative to balanced trees》中详细介绍了跳表的数据结构和插入删除等操作。&lt;/p&gt;
&lt;p&gt;跳表(SkipList，全称跳跃表)是用于有序元素序列快速搜索查找的一个数据结构，跳表是一个随机化的数据结构，实质就是一种可以进行二分查找的有序链表。跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。跳表不仅能提高搜索性能，同时也可以提高插入和删除操作的性能。它在性能上和红黑树，AVL树不相上下，但是跳表的原理非常简单，实现也比红黑树简单很多。
在这里你可以看到一些关键词：链表(有序链表)、索引、二分查找。想必你的脑海中已经有了一个初略的印象，不过你可能还是不清楚这个&amp;quot;会跳的链表&amp;quot;有多diao，甚至还可能会产生一点疑虑：跟随机化有什么关系？你在下文中很快就能得到答案！&lt;/p&gt;
&lt;p&gt;回顾链表，我们知道链表和顺序表(数组)通常都是相爱相杀，成对出现，各有优劣。而链表的优势就是更高效的插入、删除。痛点就是查询很慢很慢！每次查询都是一种O(n)复杂度的操作，链表估计自己都气的想哭了😢。&lt;/p&gt;
&lt;p&gt;图片&lt;/p&gt;
&lt;p&gt;这是一个带头结点的链表(头结点相当于一个固定的入口，不存储有意义的值)，每次查找都需要一个个枚举，相当的慢，我们能不能稍微优化一下，让它稍微跳一跳呢？答案是可以的，我们知道很多算法和数据结构以空间换时间，我们在上面加一层索引，让部分节点在上层能够直接定位到，这样链表的查询时间近乎减少一半，链表自己虽然没有开心起来，但收起了它想哭的脸。&lt;/p&gt;
&lt;p&gt;图片&lt;/p&gt;
&lt;p&gt;这样，在查询某个节点的时候，首先会从上一层快速定位节点所在的一个范围，如果找到具体范围向下然后查找代价很小，当然在表的结构设计上会增加一个向下的索引(指针)用来查找确定底层节点。平均查找速度平均为O(n/2)。但是当节点数量很大的时候，它依旧很慢很慢。我们都知道二分查找是每次都能折半的去压缩查找范围，要是有序链表也能这么跳起来那就太完美了。没错跳表就能让链表拥有近乎的接近二分查找的效率的一种数据结构，其原理依然是给上面加若干层索引，优化查找速度。&lt;/p&gt;
&lt;p&gt;图片&lt;/p&gt;
&lt;p&gt;通过上图你可以看到，通过这样的一个数据结构对有序链表进行查找都能近乎二分的性能。就是在上面维护那么多层的索引，首先在最高级索引上查找最后一个小于当前查找元素的位置，然后再跳到次高级索引继续查找，直到跳到最底层为止，这时候以及十分接近要查找的元素的位置了(如果查找元素存在的话)。由于根据索引可以一次跳过多个元素，所以跳查找的查找速度也就变快了。&lt;/p&gt;
&lt;p&gt;对于理想的跳表，每向上一层索引节点数量都是下一层的1/2.那么如果n个节点增加的节点数量(1/2+1/4+…)&amp;lt;n。并且层数较低，对查找效果影响不大。但是对于这么一个结构，你可能会疑惑，这样完美的结构真的存在吗？大概率不存在的，因为作为一个链表，少不了增删该查的一些操作。而删除和插入可能会改变整个结构，所以上面的这些都是理想的结构，在插入的时候是否添加上层索引是个概率问题(1/2的概率)，在后面会具体讲解。&lt;/p&gt;
&lt;p&gt;跳表的增删改查&lt;/p&gt;
&lt;p&gt;上面稍微了解了跳表是个啥，那么在这里就给大家谈谈跳表的增删改查过程。在实现本跳表的过程为了便于操作，我们将跳表的头结点(head)的key设为int的最小值(一定满足左小右大方便比较)。&lt;/p&gt;
&lt;p&gt;对于每个节点的设置，设置成SkipNode类，为了防止初学者将next向下还是向右搞混，直接设置right，down两个指针。&lt;/p&gt;
&lt;p&gt;class SkipNode&lt;T&gt;
{
int key;
T value;
SkipNode right,down;//右下个方向的指针
public SkipNode (int key,T value) {
this.key=key;
this.value=value;
}
}
跳表的结构和初始化也很重要，其主要参数和初始化方法为：&lt;/p&gt;
&lt;p&gt;public class SkipList &lt;T&gt; {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SkipNode headNode;//头节点，入口
int highLevel;//当前跳表索引层数
Random random;// 用于投掷硬币
final int MAX_LEVEL = 32;//最大的层

SkipList(){
    random=new Random();
    headNode=new SkipNode(Integer.MIN_VALUE,null);
    highLevel=0;
}
//其他方法
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
查询操作&lt;/p&gt;
&lt;p&gt;很多时候链表也可能这样相连仅仅是某个元素或者key作为有序的标准。所以有可能链表内部存在一些value。不过修改和查询其实都是一个操作，找到关键数字(key)。并且查找的流程也很简单，设置一个临时节点team=head。当team不为null其流程大致如下：&lt;/p&gt;
&lt;p&gt;(1) 从team节点出发，如果当前节点的key与查询的key相等，那么返回当前节点(如果是修改操作那么一直向下进行修改值即可)。&lt;/p&gt;
&lt;p&gt;(2) 如果key不相等，且右侧为null，那么证明只能向下(结果可能出现在下右方向)，此时team=team.down&lt;/p&gt;
&lt;p&gt;(3) 如果key不相等，且右侧不为null，且右侧节点key小于待查询的key。那么说明同级还可向右，此时team=team.right&lt;/p&gt;
&lt;p&gt;(4)（否则的情况）如果key不相等，且右侧不为null，且右侧节点key大于待查询的key 。那么说明如果有结果的话就在这个索引和下个索引之间，此时team=team.down。&lt;/p&gt;
&lt;p&gt;最终将按照这个步骤返回正确的节点或者null(说明没查到)。&lt;/p&gt;
&lt;p&gt;图片&lt;/p&gt;
&lt;p&gt;例如上图查询12节点，首先第一步从head出发发现右侧不为空，且7&amp;lt;12,向右；第二步右侧为null向下；第三步节点7的右侧10&amp;lt;12继续向右；第四步10右侧为null向下；第五步右侧12小于等于向右。第六步起始发现相等返回节点结束。&lt;/p&gt;
&lt;p&gt;而这块的代码也非常容易：&lt;/p&gt;
&lt;p&gt;public SkipNode search(int key) {
SkipNode team=headNode;
while (team!=null) {
if(team.key==key)
{
return  team;
}
else if(team.right==null)//右侧没有了，只能下降
{
team=team.down;
}
else if(team.right.key&amp;gt;key)//需要下降去寻找
{
team=team.down;
}
else //右侧比较小向右
{
team=team.right;
}
}
return null;
}
删除操作&lt;/p&gt;
&lt;p&gt;删除操作比起查询稍微复杂一丢丢，但是比插入简单。删除需要改变链表结构所以需要处理好节点之间的联系。对于删除操作你需要谨记以下几点：&lt;/p&gt;
&lt;p&gt;(1)删除当前节点和这个节点的前后节点都有关系&lt;/p&gt;
&lt;p&gt;(2)删除当前层节点之后，下一层该key的节点也要删除，一直删除到最底层&lt;/p&gt;
&lt;p&gt;根据这两点分析一下：如果找到当前节点了，它的前面一个节点怎么查找呢？这个总不能再遍历一遍吧！有的使用四个方向的指针(上下左右)用来找到左侧节点。是可以的，但是这里可以特殊处理一下 ，不直接判断和操作节点，先找到待删除节点的左侧节点。通过这个节点即可完成删除，然后这个节点直接向下去找下一层待删除的左侧节点。设置一个临时节点team=head，当team不为null具体循环流程为：&lt;/p&gt;
&lt;p&gt;(1)如果team右侧为null，那么team=team.down(之所以敢直接这么判断是因为左侧有头结点在左侧，不用担心特殊情况)&lt;/p&gt;
&lt;p&gt;(2)如果team右侧不 为null，并且右侧的key等于待删除的key，那么先删除节点，再team向下team=team.down为了删除下层节点。&lt;/p&gt;
&lt;p&gt;(3)如果team右侧不 为null，并且右侧key小于待删除的key，那么team向右team=team.right。&lt;/p&gt;
&lt;p&gt;(4)如果team右侧不 为null，并且右侧key大于待删除的key，那么team向下team=team.down，在下层继续查找删除节点。&lt;/p&gt;
&lt;p&gt;图片&lt;/p&gt;
&lt;p&gt;例如上图删除10节点，首先team=head从team出发，7&amp;lt;10向右(team=team.right后面省略)；第二步右侧为null只能向下；第三部右侧为10在当前层删除10节点然后向下继续查找下一层10节点；第四步8&amp;lt;10向右；第五步右侧为10删除该节点并且team向下。team为null说明删除完毕退出循环。&lt;/p&gt;
&lt;p&gt;删除操作实现的代码如下：&lt;/p&gt;
&lt;p&gt;public void delete(int key)//删除不需要考虑层数
{
SkipNode team=headNode;
while (team!=null) {
if (team.right == null) {//右侧没有了，说明这一层找到，没有只能下降
team=team.down;
}
else if(team.right.key==key)//找到节点，右侧即为待删除节点
{
team.right=team.right.right;//删除右侧节点
team=team.down;//向下继续查找删除
}
else if(team.right.key&amp;gt;key)//右侧已经不可能了，向下
{
team=team.down;
}
else { //节点还在右侧
team=team.right;
}
}
}
插入操作&lt;/p&gt;
&lt;p&gt;插入操作在实现起来是最麻烦的，需要的考虑的东西最多。回顾查询，不需要动索引；回顾删除，每层索引如果有删除就是了。但是插入不一样了，插入需要考虑是否插入索引，插入几层等问题。由于需要插入删除所以我们肯定无法维护一个完全理想的索引结构，因为它耗费的代价太高。但我们使用随机化的方法去判断是否向上层插入索引。即产生一个[0-1]的随机数如果小于0.5就向上插入索引，插入完毕后再次使用随机数判断是否向上插入索引。运气好这个值可能是多层索引，运气不好只插入最底层(这是100%插入的)。但是索引也不能不限制高度，我们一般会设置索引最高值如果大于这个值就不往上继续添加索引了。&lt;/p&gt;
&lt;p&gt;我们一步步剖析该怎么做，其流程为&lt;/p&gt;
&lt;p&gt;(1)首先通过上面查找的方式，找到待插入的左节点。插入的话最底层肯定是需要插入的，所以通过链表插入节点(需要考虑是否为末尾节点)&lt;/p&gt;
&lt;p&gt;(2)插入完这一层，需要考虑上一层是否插入，首先判断当前索引层级，如果大于最大值那么就停止(比如已经到最高索引层了)。否则设置一个随机数1/2的概率向上插入一层索引(因为理想状态下的就是每2个向上建一个索引节点)。&lt;/p&gt;
&lt;p&gt;(3)继续(2)的操作，直到概率退出或者索引层数大于最大索引层。&lt;/p&gt;
&lt;p&gt;在具体向上插入的时候，实质上还有非常重要的细节需要考虑。首先如何找到上层的待插入节点 ？&lt;/p&gt;
&lt;p&gt;这个各个实现方法可能不同，如果有左、上指向的指针那么可以向左向上找到上层需要插入的节点，但是如果只有右指向和下指向的我们也可以巧妙的借助查询过程中记录下降的节点。因为曾经下降的节点倒序就是需要插入的节点，最底层也不例外(因为没有匹配值会下降为null结束循环)。在这里我使用栈这个数据结构进行存储，当然使用List也可以。下图就是给了一个插入示意图。&lt;/p&gt;
&lt;p&gt;图片&lt;/p&gt;
&lt;p&gt;其次如果该层是目前的最高层索引，需要继续向上建立索引应该怎么办？&lt;/p&gt;
&lt;p&gt;首先跳表最初肯定是没索引的，然后慢慢添加节点才有一层、二层索引，但是如果这个节点添加的索引突破当前最高层，该怎么办呢？&lt;/p&gt;
&lt;p&gt;这时候需要注意了，跳表的head需要改变了，新建一个ListNode节点作为新的head，将它的down指向老head，将这个head节点加入栈中(也就是这个节点作为下次后面要插入的节点)，就比如上面的9节点如果运气够好在往上建立一层节点，会是这样的。&lt;/p&gt;
&lt;p&gt;图片&lt;/p&gt;
&lt;p&gt;插入上层的时候注意所有节点要新建(拷贝)，除了right的指向down的指向也不能忘记，down指向上一个节点可以用一个临时节点作为前驱节点。如果层数突破当前最高层，头head节点(入口)需要改变。&lt;/p&gt;
&lt;p&gt;这部分更多的细节在代码中注释解释了，详细代码为：&lt;/p&gt;
&lt;p&gt;public void add(SkipNode node)
{&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int key=node.key;
SkipNode findNode=search(key);
if(findNode!=null)//如果存在这个key的节点
{
    findNode.value=node.value;
    return;
}
Stack&amp;lt;SkipNode&amp;gt;stack=new Stack&amp;lt;SkipNode&amp;gt;();//存储向下的节点，这些节点可能在右侧插入节点
SkipNode team=headNode;//查找待插入的节点   找到最底层的哪个节点。
while (team!=null) {//进行查找操作 
    if(team.right==null)//右侧没有了，只能下降
    {
        stack.add(team);//将曾经向下的节点记录一下
        team=team.down;
    }
    else if(team.right.key&amp;gt;key)//需要下降去寻找
    {
        stack.add(team);//将曾经向下的节点记录一下
        team=team.down;
    }
    else //向右
    {
        team=team.right;
    }
}
int level=1;//当前层数，从第一层添加(第一层必须添加，先添加再判断)
SkipNode downNode=null;//保持前驱节点(即down的指向，初始为null)
while (!stack.isEmpty()) {
    //在该层插入node
    team=stack.pop();//抛出待插入的左侧节点
    SkipNode nodeTeam=new SkipNode(node.key, node.value);//节点需要重新创建
    nodeTeam.down=downNode;//处理竖方向
    downNode=nodeTeam;//标记新的节点下次使用
    if(team.right==null) {//右侧为null 说明插入在末尾
        team.right=nodeTeam;
    }
    //水平方向处理
    else {//右侧还有节点，插入在两者之间
        nodeTeam.right=team.right;
        team.right=nodeTeam;
    }
    //考虑是否需要向上
    if(level&amp;gt;MAX_LEVEL)//已经到达最高级的节点啦
        break;
    double num=random.nextDouble();//[0-1]随机数
    if(num&amp;gt;0.5)//运气不好结束
        break;
    level++;
    if(level&amp;gt;highLevel)//比当前最大高度要高但是依然在允许范围内 需要改变head节点
    {
        highLevel=level;
        //需要创建一个新的节点
        SkipNode highHeadNode=new SkipNode(Integer.MIN_VALUE, null);
        highHeadNode.down=headNode;
        headNode=highHeadNode;//改变head
        stack.add(headNode);//下次抛出head
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
总结&lt;/p&gt;
&lt;p&gt;对于上面，跳表完整分析就结束啦，当然，你可能看到不同品种跳表的实现，还有的用数组方式表示上下层的关系这样也可以，但本文只定义right和down两个方向的链表更纯正化的讲解跳表。&lt;/p&gt;
&lt;p&gt;对于跳表以及跳表的同类竞争产品：红黑树，为啥Redis的有序集合(zset) 使用跳表呢？因为跳表除了查找插入维护和红黑树有着差不多的效率，它是个链表，能确定范围区间，而区间问题在树上可能就没那么方便查询啦。而JDK中跳跃表ConcurrentSkipListSet和ConcurrentSkipListMap。 有兴趣的也可以查阅一下源码。&lt;/p&gt;
&lt;p&gt;对于学习，完整的代码是非常重要的，这里我把完整代码贴出来，需要的自取。&lt;/p&gt;
&lt;p&gt;import java.util.Random;
import java.util.Stack;
class SkipNode&lt;T&gt;
{
int key;
T value;
SkipNode right,down;//左右上下四个方向的指针
public SkipNode (int key,T value) {
this.key=key;
this.value=value;
}&lt;/p&gt;
&lt;p&gt;}
public class SkipList &lt;T&gt; {&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;SkipNode headNode;//头节点，入口
int highLevel;//层数
Random random;// 用于投掷硬币
final int MAX_LEVEL = 32;//最大的层
SkipList(){
    random=new Random();
    headNode=new SkipNode(Integer.MIN_VALUE,null);
    highLevel=0;
}
public SkipNode search(int key) {
    SkipNode team=headNode;
    while (team!=null) {
        if(team.key==key)
        {
            return  team;
        }
        else if(team.right==null)//右侧没有了，只能下降
        {
            team=team.down;
        }
        else if(team.right.key&amp;gt;key)//需要下降去寻找
        {
            team=team.down;
        }
        else //右侧比较小向右
        {
            team=team.right;
        }
    }
    return null;
}

public void delete(int key)//删除不需要考虑层数
{
    SkipNode team=headNode;
    while (team!=null) {
        if (team.right == null) {//右侧没有了，说明这一层找到，没有只能下降
            team=team.down;
        }
        else if(team.right.key==key)//找到节点，右侧即为待删除节点
        {
            team.right=team.right.right;//删除右侧节点
            team=team.down;//向下继续查找删除
        }
        else if(team.right.key&amp;gt;key)//右侧已经不可能了，向下
        {
            team=team.down;
        }
        else { //节点还在右侧
            team=team.right;
        }
    }
}
public void add(SkipNode node)
{

    int key=node.key;
    SkipNode findNode=search(key);
    if(findNode!=null)//如果存在这个key的节点
    {
        findNode.value=node.value;
        return;
    }

    Stack&amp;lt;SkipNode&amp;gt;stack=new Stack&amp;lt;SkipNode&amp;gt;();//存储向下的节点，这些节点可能在右侧插入节点
    SkipNode team=headNode;//查找待插入的节点   找到最底层的哪个节点。
    while (team!=null) {//进行查找操作
        if(team.right==null)//右侧没有了，只能下降
        {
            stack.add(team);//将曾经向下的节点记录一下
            team=team.down;
        }
        else if(team.right.key&amp;gt;key)//需要下降去寻找
        {
            stack.add(team);//将曾经向下的节点记录一下
            team=team.down;
        }
        else //向右
        {
            team=team.right;
        }
    }

    int level=1;//当前层数，从第一层添加(第一层必须添加，先添加再判断)
    SkipNode downNode=null;//保持前驱节点(即down的指向，初始为null)
    while (!stack.isEmpty()) {
        //在该层插入node
        team=stack.pop();//抛出待插入的左侧节点
        SkipNode nodeTeam=new SkipNode(node.key, node.value);//节点需要重新创建
        nodeTeam.down=downNode;//处理竖方向
        downNode=nodeTeam;//标记新的节点下次使用
        if(team.right==null) {//右侧为null 说明插入在末尾
            team.right=nodeTeam;
        }
        //水平方向处理
        else {//右侧还有节点，插入在两者之间
            nodeTeam.right=team.right;
            team.right=nodeTeam;
        }
        //考虑是否需要向上
        if(level&amp;gt;MAX_LEVEL)//已经到达最高级的节点啦
            break;
        double num=random.nextDouble();//[0-1]随机数
        if(num&amp;gt;0.5)//运气不好结束
            break;
        level++;
        if(level&amp;gt;highLevel)//比当前最大高度要高但是依然在允许范围内 需要改变head节点
        {
            highLevel=level;
            //需要创建一个新的节点
            SkipNode highHeadNode=new SkipNode(Integer.MIN_VALUE, null);
            highHeadNode.down=headNode;
            headNode=highHeadNode;//改变head
            stack.add(headNode);//下次抛出head
        }
    }

}
public void printList() {
    SkipNode teamNode=headNode;
    int index=1;
    SkipNode last=teamNode;
    while (last.down!=null){
        last=last.down;
    }
    while (teamNode!=null) {
        SkipNode enumNode=teamNode.right;
        SkipNode enumLast=last.right;
        System.out.printf(&amp;quot;%-8s&amp;quot;,&amp;quot;head-&amp;gt;&amp;quot;);
        while (enumLast!=null&amp;amp;&amp;amp;enumNode!=null) {
            if(enumLast.key==enumNode.key)
            {
                System.out.printf(&amp;quot;%-5s&amp;quot;,enumLast.key+&amp;quot;-&amp;gt;&amp;quot;);
                enumLast=enumLast.right;
                enumNode=enumNode.right;
            }
            else{
                enumLast=enumLast.right;
                System.out.printf(&amp;quot;%-5s&amp;quot;,&amp;quot;&amp;quot;);
            }

        }
        teamNode=teamNode.down;
        index++;
        System.out.println();
    }
}
public static void main(String[] args) {
    SkipList&amp;lt;Integer&amp;gt;list=new SkipList&amp;lt;Integer&amp;gt;();
    for(int i=1;i&amp;lt;20;i++)
    {
        list.add(new SkipNode(i,666));
    }
    list.printList();
    list.delete(4);
    list.delete(8);
    list.printList();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;}
进行测试一下可以发现跳表还是挺完美的(自夸一下)。你是不是非常想跳一下试试！&lt;/p&gt;
&lt;p&gt;图片
推荐阅读&lt;/p&gt;
&lt;p&gt;面试官本想拿一道求素数搞我，但被我优雅的&amp;quot;回击&amp;quot;了
是时候捋一捋Java的深浅拷贝了
「干货总结」程序员必知必会的十大排序算法
花5分钟看这篇之前,你才发现你不懂RESTful
「五大常用算法」一文图解分治算法和思想
欢迎关注、转发、在看分享，咱们下次再见！
bigsai
bigsai
专注于数据结构与算法、Java知识分享，让学习更加简单！
126篇原创内容
公众号
阅读 535
赞8
在看7
：，。视频小程序赞，轻点两下取消赞在看，轻点两下取消在看&lt;/p&gt;
</description>
                
                
                
                    
                    
                    
                        
                        
                        
                            
                                <category domain="https://sslouis.com/tech/">tech</category>
                            
                        
                    
                        
                        
                        
                    
                
                
                
                    
                        
                    
                
            </item>
        
    </channel>
</rss>
